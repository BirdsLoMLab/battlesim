<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoM Battle Simulator - Alpha 3.6</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #e94560 0%, #0f3460 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1em;
        }

        .alpha-badge {
            display: inline-block;
            background: #ffc107;
            color: #000;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
        }

        .content {
            padding: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab {
            padding: 12px 24px;
            background: #e0e0e0;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .tab:hover:not(.active) {
            background: #ccc;
        }

        .tab-content {
            display: none;
            padding: 20px;
            border: 2px solid #667eea;
            border-radius: 0 12px 12px 12px;
            background: #fafafa;
        }

        .tab-content.active {
            display: block;
        }

        .section-title {
            font-size: 1.2em;
            color: #667eea;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
            font-weight: 600;
        }

        .subsection-title {
            font-size: 1em;
            color: #764ba2;
            margin: 15px 0 10px 0;
            font-weight: 600;
        }

        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .input-grid-4 {
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 600;
            margin-bottom: 6px;
            color: #333;
            font-size: 0.85em;
        }

        input, select {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.95em;
            transition: all 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        .checkbox-group label {
            margin: 0;
            font-size: 0.9em;
        }

        .pal-effect {
            font-size: 0.8em;
            color: #666;
            margin-left: 5px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #e94560 0%, #0f3460 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(233, 69, 96, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-outline {
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
        }

        .btn-outline:hover {
            background: #667eea;
            color: white;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.85em;
        }

        .btn-success {
            background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            color: #000;
        }

        .button-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
            justify-content: center;
        }

        .import-export-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 8px;
        }

        .import-export-row input[type="file"] {
            display: none;
        }

        /* OCR Import Styles */
        .ocr-section {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #e8f4fd 0%, #d1e8ff 100%);
            border-radius: 12px;
            border: 2px dashed #667eea;
        }

        .ocr-section.collapsed {
            padding: 15px;
            background: #f5f5f5;
        }

        .ocr-title {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ocr-title::before {
            content: 'Import';
        }

        .ocr-title::after {
            content: '‚ñº';
            font-size: 0.8em;
            transition: transform 0.3s;
        }

        .ocr-section.collapsed .ocr-title::after {
            transform: rotate(-90deg);
        }

        .ocr-content {
            display: block;
        }

        .ocr-section.collapsed .ocr-content {
            display: none;
        }

        .ocr-mode-select {
            margin-bottom: 15px;
        }

        .ocr-mode-select label {
            margin-right: 20px;
            cursor: pointer;
        }

        .upload-zones {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .upload-zone {
            border: 2px dashed #aaa;
            border-radius: 8px;
            padding: 15px 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .upload-zone:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .upload-zone.has-file {
            border-color: #51cf66;
            background: #e8f9ed;
        }

        .upload-zone.processing {
            border-color: #ffc107;
            background: #fff8e1;
        }

        .upload-zone input {
            display: none;
        }

        .upload-zone .icon {
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        .upload-zone .label {
            font-size: 0.75em;
            color: #666;
        }

        .upload-zone .status {
            font-size: 0.7em;
            margin-top: 5px;
            color: #888;
        }

        .upload-zone.has-file .status {
            color: #37b24d;
        }

        .ocr-progress {
            background: #e0e0e0;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            margin: 15px 0;
            display: none;
        }

        .ocr-progress.active {
            display: block;
        }

        .ocr-progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75em;
            font-weight: bold;
        }

        .ocr-status {
            font-size: 0.85em;
            color: #666;
            margin: 10px 0;
            text-align: center;
        }

        .ocr-results {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.8em;
            display: none;
        }

        .ocr-results.active {
            display: block;
        }

        .ocr-results h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .ocr-stat-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid #eee;
        }

        .ocr-stat-row:last-child {
            border-bottom: none;
        }

        .ocr-btn-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .ocr-review-panel {
            background: #f8f9fa;
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .ocr-review-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .ocr-review-columns {
                grid-template-columns: 1fr;
            }
        }

        .ocr-review-column {
            background: white;
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .ocr-stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            margin: 4px 0;
            border-radius: 4px;
            font-size: 0.85em;
        }

        .ocr-stat-item.confident {
            background: #e8f9ed;
            border-left: 3px solid #51cf66;
        }

        .ocr-stat-item.warning {
            background: #fff8e1;
            border-left: 3px solid #ffc107;
        }

        .ocr-stat-item.error {
            background: #ffe8e8;
            border-left: 3px solid #e94560;
        }

        .ocr-stat-item .stat-name {
            font-weight: 500;
            color: #333;
        }

        .ocr-stat-item .stat-value {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .ocr-stat-item .stat-value input {
            width: 80px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            text-align: right;
        }

        .ocr-stat-item.warning .stat-value input {
            border-color: #ffc107;
        }

        .ocr-stat-item.error .stat-value input {
            border-color: #e94560;
        }

        .results-section {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            color: white;
        }

        .results-section h3 {
            color: #e94560;
            margin-bottom: 20px;
            text-align: center;
        }

        .battle-display {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
        }

        .fighter-card {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }

        .fighter-card h4 {
            color: #ffc107;
            margin-bottom: 10px;
        }

        .hp-bar {
            background: #333;
            border-radius: 10px;
            height: 25px;
            overflow: hidden;
            margin: 10px 0;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.8em;
        }

        .hp-fill.enemy {
            background: linear-gradient(90deg, #e94560, #ff6b6b);
        }

        .vs-badge {
            font-size: 2em;
            color: #e94560;
            font-weight: bold;
        }

        .graph-container {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }

        .graph-container h4 {
            color: #ffc107;
            margin-bottom: 15px;
            text-align: center;
        }

        .chart-wrapper {
            position: relative;
            height: 300px;
        }

        .battle-log {
            background: #000;
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .battle-log .damage { color: #ff6b6b; }
        .battle-log .heal { color: #51cf66; }
        .battle-log .crit { color: #ffd43b; }
        .battle-log .skill { color: #74c0fc; }
        .battle-log .time { color: #868e96; }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .stat-card .value {
            font-size: 1.3em;
            color: #ffc107;
            font-weight: bold;
        }

        .stat-card .label {
            font-size: 0.8em;
            color: #aaa;
        }

        .info-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 0.9em;
            color: #856404;
        }

        .info-box.info {
            background: #e8f4fd;
            border-color: #2196F3;
            color: #0d47a1;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        @media (max-width: 900px) {
            .two-column {
                grid-template-columns: 1fr;
            }
            .battle-display {
                grid-template-columns: 1fr;
            }
            .vs-badge {
                font-size: 1.5em;
            }
        }

        .collapsible {
            cursor: pointer;
            user-select: none;
        }

        .collapsible::before {
            content: '‚ñº ';
            font-size: 0.8em;
        }

        .collapsible.collapsed::before {
            content: '‚ñ∂ ';
        }

        .collapse-content {
            overflow: hidden;
            transition: max-height 0.3s;
        }

        .collapse-content.collapsed {
            max-height: 0 !important;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Legend of Mushroom Battle Simulator <span class="alpha-badge">ALPHA 3.5</span></h1>
            <p>120-Second PvP Battle Simulation | Screenshot Import (OCR) | HP Tracking</p>
        </div>

        <div class="content">
            <!-- Tabs -->
            <div class="tabs">
                <button class="tab" onclick="showTab('import')">Import</button>
                <button class="tab active" onclick="showTab('player')">Player</button>
                <button class="tab" onclick="showTab('enemy')">Enemy</button>
                <button class="tab" onclick="showTab('equipment')">Equipment</button>
                <button class="tab" onclick="showTab('pals')">Pals</button>
                <button class="tab" onclick="showTab('talents')">Talents</button>
                <button class="tab" onclick="showTab('relics')">Relics</button>
                <button class="tab" onclick="showTab('skills')">Skills</button>
            </div>

            <!-- Import Tab (OCR) -->
            <div id="tab-import" class="tab-content">
                <div class="section-title">Import Screenshot Import (OCR)</div>
                
                <div class="info-box info">
                    <strong>How it works:</strong> Upload screenshots from the Compare screen. OCR extracts stats for both players automatically.
                    <br><strong>Tip:</strong> Use high-quality screenshots with clear text for best results.
                </div>

                <div class="ocr-mode-select" style="margin: 20px 0;">
                    <label style="margin-right: 20px; cursor: pointer;">
                        <input type="radio" name="ocrImportMode" value="playerOnly"> 
                        <strong>Player Only</strong> (left column)
                    </label>
                    <label style="cursor: pointer;">
                        <input type="radio" name="ocrImportMode" value="fullMatchup" checked> 
                        <strong>Full Matchup</strong> (both columns)
                    </label>
                </div>

                <div class="subsection-title">Upload Screenshots</div>
                <p style="font-size: 0.85em; color: #666; margin-bottom: 15px;">
                    Upload 1 Profile card + 5 Compare screen scrolls (6 total). 
                    <a href="#" onclick="showOCRInstructions(); return false;">üìã View detailed instructions</a>
                </p>

                <div class="upload-zones" id="ocrUploadZones">
                    <div class="upload-zone" onclick="document.getElementById('ocr0').click()">
                        <input type="file" id="ocr0" accept="image/*" onchange="handleOCRUpload(0, this)">
                        <div class="icon">[Player] </div>
                        <div class="label">Profile Card</div>
                        <div class="status">Click to upload</div>
                    </div>
                    <div class="upload-zone" onclick="document.getElementById('ocr1').click()">
                        <input type="file" id="ocr1" accept="image/*" onchange="handleOCRUpload(1, this)">
                        <div class="icon">üìä</div>
                        <div class="label">Compare 1/5</div>
                        <div class="status">Click to upload</div>
                    </div>
                    <div class="upload-zone" onclick="document.getElementById('ocr2').click()">
                        <input type="file" id="ocr2" accept="image/*" onchange="handleOCRUpload(2, this)">
                        <div class="icon">üìä</div>
                        <div class="label">Compare 2/5</div>
                        <div class="status">Click to upload</div>
                    </div>
                    <div class="upload-zone" onclick="document.getElementById('ocr3').click()">
                        <input type="file" id="ocr3" accept="image/*" onchange="handleOCRUpload(3, this)">
                        <div class="icon">üìä</div>
                        <div class="label">Compare 3/5</div>
                        <div class="status">Click to upload</div>
                    </div>
                    <div class="upload-zone" onclick="document.getElementById('ocr4').click()">
                        <input type="file" id="ocr4" accept="image/*" onchange="handleOCRUpload(4, this)">
                        <div class="icon">üìä</div>
                        <div class="label">Compare 4/5</div>
                        <div class="status">Click to upload</div>
                    </div>
                    <div class="upload-zone" onclick="document.getElementById('ocr5').click()">
                        <input type="file" id="ocr5" accept="image/*" onchange="handleOCRUpload(5, this)">
                        <div class="icon">üìä</div>
                        <div class="label">Compare 5/5</div>
                        <div class="status">Click to upload</div>
                    </div>
                </div>

                <div class="ocr-progress" id="ocrProgress">
                    <div class="ocr-progress-bar" id="ocrProgressBar" style="width: 0%">0%</div>
                </div>
                <div class="ocr-status" id="ocrStatus"></div>

                <div class="ocr-btn-row" style="margin-top: 15px;">
                    <button class="btn btn-secondary" onclick="processOCR()">üîç Process Screenshots</button>
                    <button class="btn btn-outline" onclick="clearOCR()">üóëÔ∏è Clear All</button>
                </div>

                <!-- OCR Results Review Panel -->
                <div class="ocr-review-panel" id="ocrReviewPanel" style="display: none;">
                    <div class="subsection-title" style="margin-top: 25px;">Review Extracted Stats</div>
                    <p style="font-size: 0.85em; color: #666; margin-bottom: 10px;">
                        <span style="color: #51cf66;">‚úÖ High confidence</span> |
                        <span style="color: #ffc107;">üîß Auto-fixed decimal</span> |
                        <span style="color: #ffc107;">‚ö†Ô∏è Low confidence</span> |
                        <span style="color: #e94560;">‚ùå Out of range</span>
                    </p>
                    
                    <div class="ocr-review-columns">
                        <div class="ocr-review-column">
                            <h4 style="color: #667eea; margin-bottom: 10px;">Player Stats</h4>
                            <div id="ocrPlayerReview"></div>
                        </div>
                        <div class="ocr-review-column" id="ocrEnemyColumn">
                            <h4 style="color: #e94560; margin-bottom: 10px;">Enemy Stats</h4>
                            <div id="ocrEnemyReview"></div>
                        </div>
                    </div>

                    <div class="ocr-btn-row" style="margin-top: 20px; justify-content: center;">
                        <button class="btn btn-primary" onclick="applyOCRStats()">‚úÖ Apply Stats to Form</button>
                        <button class="btn btn-outline" onclick="cancelOCR()">‚ùå Cancel</button>
                    </div>
                </div>
            </div>

            <!-- Player Tab -->
            <div id="tab-player" class="tab-content active">
                <div class="section-title">Class Selection</div>
                <div class="input-grid">
                    <div class="input-group">
                        <label for="playerClass">Class</label>
                        <select id="playerClass">
                            <option value="sage">Martial Sage</option>
                            <option value="hunter">Sacred Hunter</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="playerLevel">Level</label>
                        <input type="number" id="playerLevel" value="200" min="1" max="220">
                    </div>
                </div>

                <div class="info-box info">
                    <strong>Martial Sage:</strong> DEF, Counter, DMG RES, Shield specialist. 
                    <br><strong>Active:</strong> Blades Reunion (15s CD) - 12580% AoE DMG, -40% Counter DMG RES for 8s, counters deal +1% player current HP.
                    <br><strong>Passives:</strong> Restore 8% Max HP every 5s | Shield (8% Max HP) every 10s for 5s
                </div>

                <div class="section-title">Core Stats</div>
                <div class="input-grid input-grid-4">
                    <div class="input-group">
                        <label for="playerATK">ATK (Millions)</label>
                        <input type="number" id="playerATK" value="12000" step="100">
                    </div>
                    <div class="input-group">
                        <label for="playerHP">HP (Billions)</label>
                        <input type="number" id="playerHP" value="4000" step="10">
                    </div>
                    <div class="input-group">
                        <label for="playerDEF">DEF (Millions)</label>
                        <input type="number" id="playerDEF" value="5500" step="100">
                    </div>
                    <div class="input-group">
                        <label for="playerATKSPD">ATK SPD</label>
                        <input type="number" id="playerATKSPD" value="3.21" step="0.01">
                    </div>
                </div>

                <div class="subsection-title collapsible" onclick="toggleCollapse('playerMultipliers')">Multipliers</div>
                <div id="playerMultipliers" class="collapse-content">
                    <div class="input-grid input-grid-4">
                        <div class="input-group">
                            <label for="playerBasicATKMult">Basic ATK Mult %</label>
                            <input type="number" id="playerBasicATKMult" value="7500" step="100">
                        </div>
                        <div class="input-group">
                            <label for="playerComboMult">Combo Mult %</label>
                            <input type="number" id="playerComboMult" value="3500" step="10">
                        </div>
                        <div class="input-group">
                            <label for="playerCounterMult">Counter Mult %</label>
                            <input type="number" id="playerCounterMult" value="5500" step="10">
                        </div>
                        <div class="input-group">
                            <label for="playerCritDMG">Crit DMG %</label>
                            <input type="number" id="playerCritDMG" value="1000" step="10">
                        </div>
                        <div class="input-group">
                            <label for="playerSkillDMG">Skill DMG %</label>
                            <input type="number" id="playerSkillDMG" value="1450" step="10">
                        </div>
                        <div class="input-group">
                            <label for="playerSkillCritDMG">Skill Crit DMG %</label>
                            <input type="number" id="playerSkillCritDMG" value="160" step="10">
                        </div>
                        <div class="input-group">
                            <label for="playerPalDMG">Pal DMG %</label>
                            <input type="number" id="playerPalDMG" value="1377" step="10">
                        </div>
                        <div class="input-group">
                            <label for="playerBossDMG">Boss DMG %</label>
                            <input type="number" id="playerBossDMG" value="30" step="10">
                        </div>
                    </div>
                </div>

                <div class="subsection-title collapsible" onclick="toggleCollapse('playerProcRates')">Proc Rates</div>
                <div id="playerProcRates" class="collapse-content">
                    <div class="input-grid input-grid-4">
                        <div class="input-group">
                            <label for="playerCombo">Combo %</label>
                            <input type="number" id="playerCombo" value="0" step="1" max="100">
                        </div>
                        <div class="input-group">
                            <label for="playerCounter">Counter %</label>
                            <input type="number" id="playerCounter" value="135" step="1">
                        </div>
                        <div class="input-group">
                            <label for="playerCritRate">Crit Rate %</label>
                            <input type="number" id="playerCritRate" value="0" step="1" max="100">
                        </div>
                        <div class="input-group">
                            <label for="playerSkillCrit">Skill Crit %</label>
                            <input type="number" id="playerSkillCrit" value="0" step="1">
                        </div>
                        <div class="input-group">
                            <label for="playerStun">Stun %</label>
                            <input type="number" id="playerStun" value="0" step="1" max="100">
                        </div>
                        <div class="input-group">
                            <label for="playerLaunch">Launch %</label>
                            <input type="number" id="playerLaunch" value="0" step="1" max="100">
                        </div>
                        <div class="input-group">
                            <label for="playerEvasion">Evasion %</label>
                            <input type="number" id="playerEvasion" value="95" step="1">
                        </div>
                        <div class="input-group">
                            <label for="playerHealingRate">Healing Rate %</label>
                            <input type="number" id="playerHealingRate" value="50" step="1">
                        </div>
                        <div class="input-group">
                            <label for="playerHealingAmount">Healing Amount % HP</label>
                            <input type="number" id="playerHealingAmount" value="0.35" step="0.1">
                        </div>
                    </div>
                </div>

                <div class="subsection-title collapsible collapsed" onclick="toggleCollapse('playerResistances')">Resistances</div>
                <div id="playerResistances" class="collapse-content collapsed">
                    <div class="input-grid input-grid-4">
                        <div class="input-group">
                            <label for="playerDMGRES">DMG RES %</label>
                            <input type="number" id="playerDMGRES" value="45" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="playerBasicATKRES">Basic ATK RES %</label>
                            <input type="number" id="playerBasicATKRES" value="15" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="playerComboRES">Combo DMG RES %</label>
                            <input type="number" id="playerComboRES" value="35" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="playerCounterRES">Counter DMG RES %</label>
                            <input type="number" id="playerCounterRES" value="35" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="playerSkillRES">Skill DMG RES %</label>
                            <input type="number" id="playerSkillRES" value="55" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="playerPalRES">Pal DMG RES %</label>
                            <input type="number" id="playerPalRES" value="35" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="playerBossRES">Boss DMG RES %</label>
                            <input type="number" id="playerBossRES" value="20" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="playerCritRES">Crit RES %</label>
                            <input type="number" id="playerCritRES" value="3000" step="1" min="50">
                        </div>
                    </div>
                </div>

                <div class="subsection-title collapsible collapsed" onclick="toggleCollapse('playerIgnore')">Ignore Stats</div>
                <div id="playerIgnore" class="collapse-content collapsed">
                    <div class="input-grid input-grid-4">
                        <div class="input-group">
                            <label for="playerIgnoreEvasion">Ignore Evasion %</label>
                            <input type="number" id="playerIgnoreEvasion" value="135" step="1">
                        </div>
                        <div class="input-group">
                            <label for="playerIgnoreCombo">Ignore Combo %</label>
                            <input type="number" id="playerIgnoreCombo" value="60" step="1">
                        </div>
                        <div class="input-group">
                            <label for="playerIgnoreCounter">Ignore Counter %</label>
                            <input type="number" id="playerIgnoreCounter" value="60" step="1">
                        </div>
                        <div class="input-group">
                            <label for="playerIgnoreCrit">Ignore Crit %</label>
                            <input type="number" id="playerIgnoreCrit" value="5" step="1">
                        </div>
                        <div class="input-group">
                            <label for="playerIgnoreStun">Ignore Stun %</label>
                            <input type="number" id="playerIgnoreStun" value="0" step="1">
                        </div>
                        <div class="input-group">
                            <label for="playerIgnoreLaunch">Ignore Launch %</label>
                            <input type="number" id="playerIgnoreLaunch" value="0" step="1">
                        </div>
                        <div class="input-group">
                            <label for="playerIgnoreRegen">Ignore Regen %</label>
                            <input type="number" id="playerIgnoreRegen" value="0" step="1">
                        </div>
                    </div>
                </div>

                <div class="subsection-title collapsible collapsed" onclick="toggleCollapse('playerSustain')">Sustain</div>
                <div id="playerSustain" class="collapse-content collapsed">
                    <div class="input-grid input-grid-4">
                        <div class="input-group">
                            <label for="playerRegen">Regeneration %/sec</label>
                            <input type="number" id="playerRegen" value="9.5" step="0.1">
                        </div>
                    </div>
                </div>

                <!-- Player Import/Export -->
                <div class="import-export-row">
                    <button class="btn btn-small btn-success" onclick="exportConfig('player')">Export Player</button>
                    <input type="file" id="importPlayerFile" accept=".json" onchange="importConfig('player')">
                    <button class="btn btn-small btn-outline" onclick="document.getElementById('importPlayerFile').click()">Import Player</button>
                    <button class="btn btn-small btn-warning" onclick="resetFields('player')">Reset Player</button>
                </div>

            </div>

            <!-- Enemy Tab -->
            <div id="tab-enemy" class="tab-content">
                <div class="section-title">Enemy Configuration</div>
                <div class="input-grid">
                    <div class="input-group">
                        <label for="enemyClass">Class</label>
                        <select id="enemyClass">
                            <option value="sage">Martial Sage</option>
                            <option value="hunter">Sacred Hunter</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label for="enemyLevel">Level</label>
                        <input type="number" id="enemyLevel" value="200" min="1" max="220">
                    </div>
                </div>

                <div class="section-title">Core Stats</div>
                <div class="input-grid input-grid-4">
                    <div class="input-group">
                        <label for="enemyATK">ATK (Millions)</label>
                        <input type="number" id="enemyATK" value="12000" step="100">
                    </div>
                    <div class="input-group">
                        <label for="enemyHP">HP (Billions)</label>
                        <input type="number" id="enemyHP" value="4000" step="10">
                    </div>
                    <div class="input-group">
                        <label for="enemyDEF">DEF (Millions)</label>
                        <input type="number" id="enemyDEF" value="5500" step="100">
                    </div>
                    <div class="input-group">
                        <label for="enemyATKSPD">ATK SPD</label>
                        <input type="number" id="enemyATKSPD" value="3.21" step="0.01">
                    </div>
                </div>

                <div class="subsection-title collapsible" onclick="toggleCollapse('enemyMultipliers')">Multipliers</div>
                <div id="enemyMultipliers" class="collapse-content">
                    <div class="input-grid input-grid-4">
                        <div class="input-group">
                            <label for="enemyBasicATKMult">Basic ATK Mult %</label>
                            <input type="number" id="enemyBasicATKMult" value="7500" step="100">
                        </div>
                        <div class="input-group">
                            <label for="enemyComboMult">Combo Mult %</label>
                            <input type="number" id="enemyComboMult" value="3500" step="10">
                        </div>
                        <div class="input-group">
                            <label for="enemyCounterMult">Counter Mult %</label>
                            <input type="number" id="enemyCounterMult" value="5500" step="10">
                        </div>
                        <div class="input-group">
                            <label for="enemyCritDMG">Crit DMG %</label>
                            <input type="number" id="enemyCritDMG" value="1000" step="10">
                        </div>
                        <div class="input-group">
                            <label for="enemySkillDMG">Skill DMG %</label>
                            <input type="number" id="enemySkillDMG" value="1450" step="10">
                        </div>
                        <div class="input-group">
                            <label for="enemySkillCritDMG">Skill Crit DMG %</label>
                            <input type="number" id="enemySkillCritDMG" value="160" step="10">
                        </div>
                        <div class="input-group">
                            <label for="enemyPalDMG">Pal DMG %</label>
                            <input type="number" id="enemyPalDMG" value="1377" step="10">
                        </div>
                        <div class="input-group">
                            <label for="enemyBossDMG">Boss DMG %</label>
                            <input type="number" id="enemyBossDMG" value="30" step="10">
                        </div>
                    </div>
                </div>

                <div class="subsection-title collapsible" onclick="toggleCollapse('enemyProcRates')">Proc Rates</div>
                <div id="enemyProcRates" class="collapse-content">
                    <div class="input-grid input-grid-4">
                        <div class="input-group">
                            <label for="enemyCombo">Combo %</label>
                            <input type="number" id="enemyCombo" value="0" step="1" max="100">
                        </div>
                        <div class="input-group">
                            <label for="enemyCounter">Counter %</label>
                            <input type="number" id="enemyCounter" value="135" step="1">
                        </div>
                        <div class="input-group">
                            <label for="enemyCritRate">Crit Rate %</label>
                            <input type="number" id="enemyCritRate" value="0" step="1" max="100">
                        </div>
                        <div class="input-group">
                            <label for="enemySkillCrit">Skill Crit %</label>
                            <input type="number" id="enemySkillCrit" value="0" step="1">
                        </div>
                        <div class="input-group">
                            <label for="enemyStun">Stun %</label>
                            <input type="number" id="enemyStun" value="0" step="1" max="100">
                        </div>
                        <div class="input-group">
                            <label for="enemyLaunch">Launch %</label>
                            <input type="number" id="enemyLaunch" value="0" step="1" max="100">
                        </div>
                        <div class="input-group">
                            <label for="enemyEvasion">Evasion %</label>
                            <input type="number" id="enemyEvasion" value="95" step="1">
                        </div>
                        <div class="input-group">
                            <label for="enemyHealingRate">Healing Rate %</label>
                            <input type="number" id="enemyHealingRate" value="50" step="1">
                        </div>
                        <div class="input-group">
                            <label for="enemyHealingAmount">Healing Amount % HP</label>
                            <input type="number" id="enemyHealingAmount" value="0.35" step="0.1">
                        </div>
                    </div>
                </div>

                <div class="subsection-title collapsible collapsed" onclick="toggleCollapse('enemyResistances')">Resistances</div>
                <div id="enemyResistances" class="collapse-content collapsed">
                    <div class="input-grid input-grid-4">
                        <div class="input-group">
                            <label for="enemyDMGRES">DMG RES %</label>
                            <input type="number" id="enemyDMGRES" value="45" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="enemyBasicATKRES">Basic ATK RES %</label>
                            <input type="number" id="enemyBasicATKRES" value="15" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="enemyComboRES">Combo DMG RES %</label>
                            <input type="number" id="enemyComboRES" value="35" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="enemyCounterRES">Counter DMG RES %</label>
                            <input type="number" id="enemyCounterRES" value="35" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="enemySkillRES">Skill DMG RES %</label>
                            <input type="number" id="enemySkillRES" value="55" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="enemyPalRES">Pal DMG RES %</label>
                            <input type="number" id="enemyPalRES" value="35" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="enemyBossRES">Boss DMG RES %</label>
                            <input type="number" id="enemyBossRES" value="20" step="1" max="80">
                        </div>
                        <div class="input-group">
                            <label for="enemyCritRES">Crit RES %</label>
                            <input type="number" id="enemyCritRES" value="3000" step="1" min="50">
                        </div>
                    </div>
                </div>

                <div class="subsection-title collapsible collapsed" onclick="toggleCollapse('enemyIgnore')">Ignore Stats</div>
                <div id="enemyIgnore" class="collapse-content collapsed">
                    <div class="input-grid input-grid-4">
                        <div class="input-group">
                            <label for="enemyIgnoreEvasion">Ignore Evasion %</label>
                            <input type="number" id="enemyIgnoreEvasion" value="135" step="1">
                        </div>
                        <div class="input-group">
                            <label for="enemyIgnoreCombo">Ignore Combo %</label>
                            <input type="number" id="enemyIgnoreCombo" value="60" step="1">
                        </div>
                        <div class="input-group">
                            <label for="enemyIgnoreCounter">Ignore Counter %</label>
                            <input type="number" id="enemyIgnoreCounter" value="60" step="1">
                        </div>
                        <div class="input-group">
                            <label for="enemyIgnoreCrit">Ignore Crit %</label>
                            <input type="number" id="enemyIgnoreCrit" value="5" step="1">
                        </div>
                        <div class="input-group">
                            <label for="enemyIgnoreStun">Ignore Stun %</label>
                            <input type="number" id="enemyIgnoreStun" value="0" step="1">
                        </div>
                        <div class="input-group">
                            <label for="enemyIgnoreLaunch">Ignore Launch %</label>
                            <input type="number" id="enemyIgnoreLaunch" value="0" step="1">
                        </div>
                        <div class="input-group">
                            <label for="enemyIgnoreRegen">Ignore Regen %</label>
                            <input type="number" id="enemyIgnoreRegen" value="0" step="1">
                        </div>
                    </div>
                </div>

                <div class="subsection-title collapsible collapsed" onclick="toggleCollapse('enemySustain')">Sustain</div>
                <div id="enemySustain" class="collapse-content collapsed">
                    <div class="input-grid input-grid-4">
                        <div class="input-group">
                            <label for="enemyRegen">Regeneration %/sec</label>
                            <input type="number" id="enemyRegen" value="9.5" step="0.1">
                        </div>
                    </div>
                </div>

                <!-- Enemy Import/Export -->
                <div class="import-export-row">
                    <button class="btn btn-small btn-success" onclick="exportConfig('enemy')">Export Enemy</button>
                    <input type="file" id="importEnemyFile" accept=".json" onchange="importConfig('enemy')">
                    <button class="btn btn-small btn-outline" onclick="document.getElementById('importEnemyFile').click()">Import Enemy</button>
                    <button class="btn btn-small btn-warning" onclick="resetFields('enemy')">Reset Enemy</button>
                </div>

            </div>

            <!-- Equipment Tab -->
            <div id="tab-equipment" class="tab-content">
                <div class="two-column">
                    <div>
                        <div class="section-title">Player Equipment</div>
                        
                        <div class="subsection-title">Avian</div>
                        <div class="input-grid">
                            <div class="input-group">
                                <label for="playerAvian">Avian Companion</label>
                                <select id="playerAvian" onchange="onAvianChange('player')">
                                    <option value="none">None</option>
                                    <option value="bee">Honeypot Warrior (Bee)</option>
                                    <option value="deity" selected>Deity of Purrs</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label for="playerAvianHPPercent">HP DMG (%)</label>
                                <input type="number" id="playerAvianHPPercent" value="5.87" step="0.1" min="0">
                            </div>
                            <div class="input-group">
                                <label for="playerAvianInterval">Interval (s)</label>
                                <input type="number" id="playerAvianInterval" value="16" step="1" min="1">
                            </div>
                        </div>
                        <div class="info-box">
                            <strong>Bee:</strong> 2.5% of player's Max HP every 5s | <strong>Deity:</strong> 4% of player's Current HP per 16 heals received<br>
                            <small style="opacity:0.7">HP DMG values = % of player's own HP. No resistances apply. Cannot crit.</small>
                        </div>

                        <div class="subsection-title">Avian Affixes</div>
                        <div class="input-grid input-grid-4">
                            <div class="input-group">
                                <label><input type="checkbox" id="playerAffixPunchCounter" checked> Punch Counter</label>
                                <input type="number" id="playerAffixPunchCounterHP" value="1.2" step="0.1" min="0" title="HP DMG (%) on counter (50% chance)">
                            </div>
                            <div class="input-group">
                                <label><input type="checkbox" id="playerAffixWindTear" checked> Wind Tear</label>
                                <input type="number" id="playerAffixWindTearHP" value="2.4" step="0.1" min="0" title="HP DMG (%) on active skill">
                            </div>
                            <div class="input-group">
                                <label><input type="checkbox" id="playerAffixRageSlash"> Rage Slash</label>
                                <input type="number" id="playerAffixRageSlashATK" value="0.4" step="0.1" min="0" title="% ATK boost per second (>50% HP, max 30 stacks)">
                            </div>
                            <div class="input-group">
                                <label><input type="checkbox" id="playerAffixTerminalStrike"> Terminal Strike</label>
                                <input type="number" id="playerAffixTerminalStrikeChance" value="8" step="1" min="0" max="100" title="% chance per basic ATK to wound (-50% regen/healing 1s)">
                            </div>
                        </div>
                        <div class="input-grid">
                            <div class="input-group">
                                <label><input type="checkbox" id="playerAffixNoSpeeding" checked> No Speeding</label>
                                <input type="number" id="playerAffixNoSpeedingReduce" value="19.2" step="1" min="0" title="% reduction to enemy active skill duration">
                            </div>
                        </div>
                    </div>

                    <div>
                        <div class="section-title">Enemy Equipment</div>
                        
                        <div class="subsection-title">Avian</div>
                        <div class="input-grid">
                            <div class="input-group">
                                <label for="enemyAvian">Avian Companion</label>
                                <select id="enemyAvian" onchange="onAvianChange('enemy')">
                                    <option value="none">None</option>
                                    <option value="bee">Honeypot Warrior (Bee)</option>
                                    <option value="deity" selected>Deity of Purrs</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label for="enemyAvianHPPercent">HP DMG (%)</label>
                                <input type="number" id="enemyAvianHPPercent" value="5.87" step="0.1" min="0">
                            </div>
                            <div class="input-group">
                                <label for="enemyAvianInterval">Interval (s)</label>
                                <input type="number" id="enemyAvianInterval" value="16" step="1" min="1">
                            </div>
                        </div>

                        <div class="subsection-title">Avian Affixes</div>
                        <div class="input-grid input-grid-4">
                            <div class="input-group">
                                <label><input type="checkbox" id="enemyAffixPunchCounter" checked> Punch Counter</label>
                                <input type="number" id="enemyAffixPunchCounterHP" value="1.2" step="0.1" min="0" title="HP DMG (%) on counter (50% chance)">
                            </div>
                            <div class="input-group">
                                <label><input type="checkbox" id="enemyAffixWindTear" checked> Wind Tear</label>
                                <input type="number" id="enemyAffixWindTearHP" value="2.4" step="0.1" min="0" title="HP DMG (%) on active skill">
                            </div>
                            <div class="input-group">
                                <label><input type="checkbox" id="enemyAffixRageSlash"> Rage Slash</label>
                                <input type="number" id="enemyAffixRageSlashATK" value="0.4" step="0.1" min="0" title="% ATK boost per second (>50% HP, max 30 stacks)">
                            </div>
                            <div class="input-group">
                                <label><input type="checkbox" id="enemyAffixTerminalStrike"> Terminal Strike</label>
                                <input type="number" id="enemyAffixTerminalStrikeChance" value="8" step="1" min="0" max="100" title="% chance per basic ATK to wound (-50% regen/healing 1s)">
                            </div>
                        </div>
                        <div class="input-grid">
                            <div class="input-group">
                                <label><input type="checkbox" id="enemyAffixNoSpeeding" checked> No Speeding</label>
                                <input type="number" id="enemyAffixNoSpeedingReduce" value="19.2" step="1" min="0" title="% reduction to enemy active skill duration">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pals Tab -->
            <div id="tab-pals" class="tab-content">
                <div class="info-box info">
                    <strong>Note:</strong> Select any number of pals. Raw stat pals (ATK%, HP%, DEF%, etc.) are already reflected in your stats ‚Äî only pals with unique combat mechanics are listed here.
                </div>
                <div class="two-column">
                    <div>
                        <div class="section-title">Player Pals</div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerPalBDuck">
                            <label for="playerPalBDuck">B.Duck</label>
                            <span class="pal-effect">(Extends all shield durations by 1.5s)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerPalPuppyFervor">
                            <label for="playerPalPuppyFervor">Puppy Fervor</label>
                            <span class="pal-effect">(+20% shield effectiveness)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerPalFloralPanda">
                            <label for="playerPalFloralPanda">Floral Panda</label>
                            <span class="pal-effect">(Base Regen +0.1%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerPalAlpacaBell">
                            <label for="playerPalAlpacaBell">Alpaca Bell</label>
                            <span class="pal-effect">(Enemy ATK -6%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerPalMellowCloud">
                            <label for="playerPalMellowCloud">Mellow Cloud</label>
                            <span class="pal-effect">(Enemy +10% ATK SPD, -15% Basic/Combo/Counter DMG)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerPalWolf" checked>
                            <label for="playerPalWolf">Moonlit Lonewolf</label>
                            <span class="pal-effect">(Enemy HP Regen -10%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerPalTreasureDragon">
                            <label for="playerPalTreasureDragon">Treasure Dragon</label>
                            <span class="pal-effect">(BasicATK CritDMG +50%, Skill Crit +20%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerPalPup" checked>
                            <label for="playerPalPup">Electric Pup</label>
                            <span class="pal-effect">(Counter DMG +60%, heal 1% lost HP on counter)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerPalHydro" checked>
                            <label for="playerPalHydro">Warlord Hydrosprite</label>
                            <span class="pal-effect">(Skill CDR +25%)</span>
                        </div>
                    </div>
                    <div>
                        <div class="section-title">Enemy Pals</div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyPalBDuck">
                            <label for="enemyPalBDuck">B.Duck</label>
                            <span class="pal-effect">(Extends all shield durations by 1.5s)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyPalPuppyFervor">
                            <label for="enemyPalPuppyFervor">Puppy Fervor</label>
                            <span class="pal-effect">(+20% shield effectiveness)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyPalFloralPanda">
                            <label for="enemyPalFloralPanda">Floral Panda</label>
                            <span class="pal-effect">(Base Regen +0.1%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyPalAlpacaBell">
                            <label for="enemyPalAlpacaBell">Alpaca Bell</label>
                            <span class="pal-effect">(Enemy ATK -6%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyPalMellowCloud">
                            <label for="enemyPalMellowCloud">Mellow Cloud</label>
                            <span class="pal-effect">(Enemy +10% ATK SPD, -15% Basic/Combo/Counter DMG)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyPalWolf" checked>
                            <label for="enemyPalWolf">Moonlit Lonewolf</label>
                            <span class="pal-effect">(Enemy HP Regen -10%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyPalTreasureDragon">
                            <label for="enemyPalTreasureDragon">Treasure Dragon</label>
                            <span class="pal-effect">(BasicATK CritDMG +50%, Skill Crit +20%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyPalPup" checked>
                            <label for="enemyPalPup">Electric Pup</label>
                            <span class="pal-effect">(Counter DMG +60%, heal 1% lost HP on counter)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyPalHydro" checked>
                            <label for="enemyPalHydro">Warlord Hydrosprite</label>
                            <span class="pal-effect">(Skill CDR +25%)</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Talents Tab -->
            <div id="tab-talents" class="tab-content">
                <div class="info-box info">
                    <strong>Note:</strong> Final Talents are on/off toggles (max 4 in-game). Leveled talents use numeric inputs matching your in-game values.
                </div>
                <div class="two-column">
                    <div>
                        <div class="section-title">Player Talents</div>
                        <strong style="display:block; margin: 8px 0 4px;">Final Talents</strong>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerTalentAscension" checked>
                            <label for="playerTalentAscension">Ascension</label>
                            <span class="pal-effect">(15s: ATK SPD +15%, 30s: Crit Rate +20%, 45s: ATK +20%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerTalentRampage">
                            <label for="playerTalentRampage">Rampage</label>
                            <span class="pal-effect">(HP &lt;20%: ATK +10%, ATK SPD +10%, Crit DMG +10%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerTalentEagerMomentum">
                            <label for="playerTalentEagerMomentum">Eager Momentum</label>
                            <span class="pal-effect">(Every 3s: Crit DMG +5%, up to 25%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerTalentGaleBarrage">
                            <label for="playerTalentGaleBarrage">Gale Barrage</label>
                            <span class="pal-effect">(Every 2s: Combo DMG +5%, up to 50%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerTalentTemporalCompression" checked>
                            <label for="playerTalentTemporalCompression">Temporal Compression</label>
                            <span class="pal-effect">(Each skill cast: ATK +2%, up to 30%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerTalentEndlessOutburst">
                            <label for="playerTalentEndlessOutburst">Endless Outburst</label>
                            <span class="pal-effect">(First HP &lt;20%: Energy Regen +100% for 5s)</span>
                        </div>
                        <strong style="display:block; margin: 12px 0 4px;">Leveled Talents</strong>
                        <div class="input-grid input-grid-4">
                            <div class="input-group">
                                <label for="playerTalentWound">Wound %</label>
                                <input type="number" id="playerTalentWound" value="20" step="0.5" min="0" max="20">
                            </div>
                            <div class="input-group">
                                <label for="playerTalentEnergyRegen">Energy Regen %</label>
                                <input type="number" id="playerTalentEnergyRegen" value="20" step="0.5" min="0" max="20">
                            </div>
                            <div class="input-group">
                                <label for="playerTalentCounterRejuv">Counter Rejuv %HP</label>
                                <input type="number" id="playerTalentCounterRejuv" value="1" step="0.05" min="0" max="1">
                            </div>
                            <div class="input-group">
                                <label for="playerTalentComboHealing">Combo Heal %HP</label>
                                <input type="number" id="playerTalentComboHealing" value="0" step="0.05" min="0" max="1">
                            </div>
                            <div class="input-group">
                                <label for="playerTalentSkillRegen">Skill Regen %HP</label>
                                <input type="number" id="playerTalentSkillRegen" value="0.88" step="0.04" min="0" max="0.88">
                            </div>
                        </div>
                    </div>
                    <div>
                        <div class="section-title">Enemy Talents</div>
                        <strong style="display:block; margin: 8px 0 4px;">Final Talents</strong>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyTalentAscension" checked>
                            <label for="enemyTalentAscension">Ascension</label>
                            <span class="pal-effect">(15s: ATK SPD +15%, 30s: Crit Rate +20%, 45s: ATK +20%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyTalentRampage">
                            <label for="enemyTalentRampage">Rampage</label>
                            <span class="pal-effect">(HP &lt;20%: ATK +10%, ATK SPD +10%, Crit DMG +10%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyTalentEagerMomentum">
                            <label for="enemyTalentEagerMomentum">Eager Momentum</label>
                            <span class="pal-effect">(Every 3s: Crit DMG +5%, up to 25%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyTalentGaleBarrage">
                            <label for="enemyTalentGaleBarrage">Gale Barrage</label>
                            <span class="pal-effect">(Every 2s: Combo DMG +5%, up to 50%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyTalentTemporalCompression" checked>
                            <label for="enemyTalentTemporalCompression">Temporal Compression</label>
                            <span class="pal-effect">(Each skill cast: ATK +2%, up to 30%)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyTalentEndlessOutburst">
                            <label for="enemyTalentEndlessOutburst">Endless Outburst</label>
                            <span class="pal-effect">(First HP &lt;20%: Energy Regen +100% for 5s)</span>
                        </div>
                        <strong style="display:block; margin: 12px 0 4px;">Leveled Talents</strong>
                        <div class="input-grid input-grid-4">
                            <div class="input-group">
                                <label for="enemyTalentWound">Wound %</label>
                                <input type="number" id="enemyTalentWound" value="20" step="0.5" min="0" max="20">
                            </div>
                            <div class="input-group">
                                <label for="enemyTalentEnergyRegen">Energy Regen %</label>
                                <input type="number" id="enemyTalentEnergyRegen" value="20" step="0.5" min="0" max="20">
                            </div>
                            <div class="input-group">
                                <label for="enemyTalentCounterRejuv">Counter Rejuv %HP</label>
                                <input type="number" id="enemyTalentCounterRejuv" value="1" step="0.05" min="0" max="1">
                            </div>
                            <div class="input-group">
                                <label for="enemyTalentComboHealing">Combo Heal %HP</label>
                                <input type="number" id="enemyTalentComboHealing" value="0" step="0.05" min="0" max="1">
                            </div>
                            <div class="input-group">
                                <label for="enemyTalentSkillRegen">Skill Regen %HP</label>
                                <input type="number" id="enemyTalentSkillRegen" value="0.88" step="0.04" min="0" max="0.88">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Relics Tab -->
            <div id="tab-relics" class="tab-content">
                <div class="info-box info">
                    <strong>Note:</strong> Relics provide passive combat effects. Kite and Flame Book are on/off toggles. Necklace, Statue, and Spore are choose-one dropdowns. Potent Spore amplifies all other relic effects by 40%.
                </div>
                <div class="two-column">
                    <div>
                        <div class="section-title">Player Relics</div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerRelicKite" checked>
                            <label for="playerRelicKite">Thundercaller Kite</label>
                            <span class="pal-effect">(After active skills, deal 1705% DMG)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="playerRelicFlameBook" checked>
                            <label for="playerRelicFlameBook">Flame Book</label>
                            <span class="pal-effect">(ATK +1%/s, up to 10%)</span>
                        </div>
                        <div class="input-grid input-grid-4" style="margin-top: 10px;">
                            <div class="input-group">
                                <label for="playerRelicNecklace">Necklace</label>
                                <select id="playerRelicNecklace">
                                    <option value="none">None</option>
                                    <option value="abyss" selected>Abyss</option>
                                    <option value="shield">Shield</option>
                                    <option value="crimsonSickle">Crimson Sickle</option>
                                    <option value="storm">Storm</option>
                                    <option value="spirit">Spirit</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label for="playerRelicStatue">Statue</label>
                                <select id="playerRelicStatue">
                                    <option value="none">None</option>
                                    <option value="energy" selected>Energy</option>
                                    <option value="cage">Cage</option>
                                    <option value="crystal">Crystal</option>
                                    <option value="time">Time</option>
                                    <option value="stellar">Stellar</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label for="playerRelicSpore">Spore</label>
                                <select id="playerRelicSpore">
                                    <option value="none">None</option>
                                    <option value="potent" selected>Potent</option>
                                    <option value="thorny">Thorny</option>
                                    <option value="nirvana">Nirvana</option>
                                </select>
                            </div>
                        </div>
                        <div class="info-box" style="margin-top: 8px; font-size: 0.85em; padding: 8px;">
                            <strong>Necklace:</strong> Abyss = CDR +30% for Dragonic Res/Windborne/Crimson Moon/Winged Dreams |
                            Shield = Grim Reaper DMG +80% | Crimson Sickle = Heal 2.5% HP on Blade Pierce/Wild Gust |
                            Storm = Clone DMG +30% | Spirit = Basic ATK +15% during Blitz Assault<br>
                            <strong>Statue:</strong> Energy = Batty/Renewal/Shroom DMG +30% | Cage = Durian/Breezy/Slow +30% |
                            Crystal = Coin/Slime/Meteor +30% | Time = Disarm/Dazzled/Smoke dur +30% |
                            Stellar = Hundred Slashes/Snare/Star Array/Ancestral dur +50%<br>
                            <strong>Spore:</strong> Potent = All relic effects +40% | Thorny = Enemy class skill dur -20% |
                            Nirvana = HP capped at 40% for low-HP triggers
                        </div>
                    </div>
                    <div>
                        <div class="section-title">Enemy Relics</div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyRelicKite" checked>
                            <label for="enemyRelicKite">Thundercaller Kite</label>
                            <span class="pal-effect">(After active skills, deal 1705% DMG)</span>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enemyRelicFlameBook" checked>
                            <label for="enemyRelicFlameBook">Flame Book</label>
                            <span class="pal-effect">(ATK +1%/s, up to 10%)</span>
                        </div>
                        <div class="input-grid input-grid-4" style="margin-top: 10px;">
                            <div class="input-group">
                                <label for="enemyRelicNecklace">Necklace</label>
                                <select id="enemyRelicNecklace">
                                    <option value="none">None</option>
                                    <option value="abyss" selected>Abyss</option>
                                    <option value="shield">Shield</option>
                                    <option value="crimsonSickle">Crimson Sickle</option>
                                    <option value="storm">Storm</option>
                                    <option value="spirit">Spirit</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label for="enemyRelicStatue">Statue</label>
                                <select id="enemyRelicStatue">
                                    <option value="none">None</option>
                                    <option value="energy" selected>Energy</option>
                                    <option value="cage">Cage</option>
                                    <option value="crystal">Crystal</option>
                                    <option value="time">Time</option>
                                    <option value="stellar">Stellar</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label for="enemyRelicSpore">Spore</label>
                                <select id="enemyRelicSpore">
                                    <option value="none">None</option>
                                    <option value="potent" selected>Potent</option>
                                    <option value="thorny">Thorny</option>
                                    <option value="nirvana">Nirvana</option>
                                </select>
                            </div>
                        </div>
                        <div class="info-box" style="margin-top: 8px; font-size: 0.85em; padding: 8px;">
                            <strong>Necklace:</strong> Abyss = CDR +30% for Dragonic Res/Windborne/Crimson Moon/Winged Dreams |
                            Shield = Grim Reaper DMG +80% | Crimson Sickle = Heal 2.5% HP on Blade Pierce/Wild Gust |
                            Storm = Clone DMG +30% | Spirit = Basic ATK +15% during Blitz Assault<br>
                            <strong>Statue:</strong> Energy = Batty/Renewal/Shroom DMG +30% | Cage = Durian/Breezy/Slow +30% |
                            Crystal = Coin/Slime/Meteor +30% | Time = Disarm/Dazzled/Smoke dur +30% |
                            Stellar = Hundred Slashes/Snare/Star Array/Ancestral dur +50%<br>
                            <strong>Spore:</strong> Potent = All relic effects +40% | Thorny = Enemy class skill dur -20% |
                            Nirvana = HP capped at 40% for low-HP triggers
                        </div>
                    </div>
                </div>
            </div>

            <!-- Skills Tab -->
            <div id="tab-skills" class="tab-content">
                <div class="info-box info">
                    <strong>Note:</strong> Equip up to 5 active skills per side. Class skill (Blades Reunion for Martial Sage) is always active.
                    Check "Custom" to override the skill damage % (values scale with level in-game).
                </div>
                <div class="two-column">
                    <div>
                        <div class="section-title">Player Skills</div>
                        <div id="playerSkillSlots"></div>
                    </div>
                    <div>
                        <div class="section-title">Enemy Skills</div>
                        <div id="enemySkillSlots"></div>
                    </div>
                </div>
            </div>

            <!-- Battle Controls -->
            <div class="button-row">
                <button class="btn btn-primary" onclick="runSimulation()">Run 120s Battle Simulation</button>
            </div>

            <!-- Results Section -->
            <div id="results-section" class="results-section hidden">
                <h3>Battle Results</h3>

                <div class="battle-display">
                    <div class="fighter-card">
                        <h4>Player</h4>
                        <div class="hp-bar">
                            <div class="hp-fill" id="playerHPBar" style="width: 100%;">100%</div>
                        </div>
                        <div id="playerHPText">HP: 1500B / 1500B</div>
                    </div>
                    <div class="vs-badge">VS</div>
                    <div class="fighter-card">
                        <h4>Enemy</h4>
                        <div class="hp-bar">
                            <div class="hp-fill enemy" id="enemyHPBar" style="width: 100%;">100%</div>
                        </div>
                        <div id="enemyHPText">HP: 1500B / 1500B</div>
                    </div>
                </div>

                <!-- HP Graph -->
                <div class="graph-container">
                    <h4>HP Over Time</h4>
                    <div id="chartToggles" style="display:flex;flex-wrap:wrap;gap:6px 12px;margin-bottom:8px;font-size:0.8em;">
                        <label style="color:#51cf66;cursor:pointer;"><input type="checkbox" id="togglePlayerCDR" onchange="renderHPChart()"> P: CDR</label>
                        <label style="color:#74c0fc;cursor:pointer;"><input type="checkbox" id="togglePlayerATK" onchange="renderHPChart()"> P: ATK%</label>
                        <label style="color:#ff6b6b;cursor:pointer;"><input type="checkbox" id="toggleEnemyCDR" onchange="renderHPChart()"> E: CDR</label>
                        <label style="color:#ffa8a8;cursor:pointer;"><input type="checkbox" id="toggleEnemyATK" onchange="renderHPChart()"> E: ATK%</label>
                        <span id="skillTogglesPlayer" style="display:contents;"></span>
                        <span id="skillTogglesEnemy" style="display:contents;"></span>
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="hpChart"></canvas>
                    </div>
                </div>

                <div class="stats-summary">
                    <div class="stat-card">
                        <div class="value" id="resultWinner">-</div>
                        <div class="label">Winner</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="resultDuration">-</div>
                        <div class="label">Duration</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="resultPlayerDMG">-</div>
                        <div class="label">Player Total DMG</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="resultEnemyDMG">-</div>
                        <div class="label">Enemy Total DMG</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="resultPlayerDPS">-</div>
                        <div class="label">Player DPS</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="resultEnemyDPS">-</div>
                        <div class="label">Enemy DPS</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="resultPlayerHeals">-</div>
                        <div class="label">Player Heal Procs</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="resultEnemyHeals">-</div>
                        <div class="label">Enemy Heal Procs</div>
                    </div>
                </div>

                <!-- Per-source Damage Breakdown -->
                <div class="subsection-title" style="color: white; margin-top: 20px;">Damage Breakdown</div>
                <div id="damageBreakdown" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;"></div>

                <div class="subsection-title" style="color: white; margin-top: 20px;">
                    Battle Log
                    <label style="font-size: 0.8em; font-weight: normal; margin-left: 15px;">
                        <input type="checkbox" id="showFullLog" onchange="toggleFullLog()"> Show Full Log
                    </label>
                </div>
                <div class="battle-log" id="battleLog"></div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // DATA
        // ============================================

        const PVP_FACTORS = {
            1: 1.00, 2: 1.00, 3: 1.00, 4: 1.00, 5: 1.00, 6: 1.00, 7: 1.00, 8: 1.10, 9: 1.15, 10: 1.40,
            11: 1.60, 12: 1.70, 13: 2.00, 14: 2.10, 15: 2.40, 16: 2.50, 17: 2.55, 18: 2.95, 19: 3.05, 20: 3.45,
            21: 3.85, 22: 4.00, 23: 4.15, 24: 4.25, 25: 4.75, 26: 4.90, 27: 5.05, 28: 5.15, 29: 5.30, 30: 5.80,
            31: 6.45, 32: 6.60, 33: 6.75, 34: 6.95, 35: 7.65, 36: 7.80, 37: 7.95, 38: 8.15, 39: 8.35, 40: 8.50,
            41: 9.35, 42: 9.50, 43: 9.70, 44: 9.90, 45: 10.05, 46: 10.25, 47: 10.45, 48: 10.65, 49: 10.80, 50: 11.00,
            51: 11.95, 52: 12.15, 53: 12.35, 54: 12.55, 55: 12.75, 56: 12.95, 57: 13.15, 58: 13.35, 59: 13.55, 60: 13.75,
            61: 14.90, 62: 15.10, 63: 15.35, 64: 15.55, 65: 16.10, 66: 16.70, 67: 17.30, 68: 17.90, 69: 18.60, 70: 19.20,
            71: 19.90, 72: 20.70, 73: 21.40, 74: 22.20, 75: 23.00, 76: 23.90, 77: 24.80, 78: 25.70, 79: 26.60, 80: 27.60,
            81: 28.60, 82: 29.70, 83: 30.80, 84: 31.90, 85: 33.10, 86: 34.30, 87: 35.60, 88: 36.90, 89: 38.20, 90: 39.60,
            91: 41.10, 92: 42.60, 93: 44.20, 94: 45.80, 95: 47.50, 96: 49.20, 97: 51.00, 98: 52.90, 99: 54.90, 100: 56.90,
            101: 59.00, 102: 61.20, 103: 63.40, 104: 65.80, 105: 68.20, 106: 70.70, 107: 73.30, 108: 76.00, 109: 78.80, 110: 81.70,
            111: 84.70, 112: 87.80, 113: 91.10, 114: 94.40, 115: 97.90, 116: 101.50, 117: 105.20, 118: 109.10, 119: 113.10, 120: 117.30,
            121: 121.60, 122: 126.10, 123: 130.80, 124: 135.60, 125: 140.60, 126: 145.80, 127: 151.00, 128: 156.20, 129: 161.40, 130: 166.60,
            131: 172.00, 132: 177.40, 133: 182.80, 134: 188.20, 135: 193.60, 136: 199.20, 137: 204.80, 138: 210.40, 139: 216.00, 140: 221.60,
            141: 227.40, 142: 233.20, 143: 239.00, 144: 244.80, 145: 250.60, 146: 256.60, 147: 262.60, 148: 268.60, 149: 274.60, 150: 280.60,
            151: 286.70, 152: 292.80, 153: 298.90, 154: 305.00, 155: 311.20, 156: 317.40, 157: 323.60, 158: 329.80, 159: 336.00, 160: 342.30,
            161: 348.60, 162: 354.90, 163: 361.20, 164: 367.50, 165: 373.90, 166: 380.30, 167: 386.70, 168: 393.10, 169: 399.50, 170: 406.00,
            171: 412.50, 172: 419.00, 173: 425.50, 174: 432.00, 175: 438.60, 176: 445.20, 177: 451.80, 178: 458.40, 179: 465.00, 180: 471.70,
            181: 478.40, 182: 485.10, 183: 491.80, 184: 498.50, 185: 505.30, 186: 512.10, 187: 518.90, 188: 525.70, 189: 532.50, 190: 539.40,
            191: 546.30, 192: 553.20, 193: 560.10, 194: 567.00, 195: 574.00, 196: 581.00, 197: 588.00, 198: 595.00, 199: 602.00, 200: 609.00,
            201: 616.10, 202: 623.20, 203: 630.30, 204: 637.40, 205: 644.50, 206: 651.70, 207: 658.90, 208: 666.10, 209: 673.30, 210: 680.50,
            211: 687.80, 212: 695.10, 213: 702.40, 214: 709.70, 215: 717.00, 216: 724.40, 217: 731.80, 218: 739.20, 219: 746.60, 220: 754.00
        };

        const PVP_HEALING_REDUCTION = 0.30;
        const PVP_SHIELD_REDUCTION = 0.40;

        // Avian companions (from LOM_all_game_data.json)
        // Bee = timed HP% procs, Deity = heal-count triggered HP% procs
        const AVIANS = {
            none:    { name: 'None',             type: 'none' },
            bee:     { name: 'Honeypot Warrior', type: 'timed',     hpPercent: 2.5, interval: 5, isMaxHP: true  },
            deity:   { name: 'Deity of Purrs',   type: 'healcount', hpPercent: 4,   healThreshold: 16, isMaxHP: false }
        };

        // Active skills (up to 5 equippable per side)
        // dmgPercent = base value from JSON (scales with level; user can override via "Custom" checkbox)
        // Effects: selfBuff, enemyDebuff, dot, hpDot, heal, shield, immunity, execute, stacking, cc
        const ACTIVE_SKILLS = [
            { id: 0,  name: 'Spore Bomb',        cd: 7,  dmgPercent: 136,   hits: 2, rarity: 'Normal',
              desc: '2 hits, each 68% DMG' },
            { id: 1,  name: 'Schroom Cap',        cd: 9,  dmgPercent: 194,   rarity: 'Normal',
              desc: '194% AoE DMG' },
            { id: 2,  name: 'Spore Barrage',      cd: 7,  dmgPercent: 165.5, hits: 5, rarity: 'Normal',
              desc: '5 hits, each 33.1% DMG' },
            { id: 3,  name: 'Boulder Impact',     cd: 12, dmgPercent: 380,   rarity: 'Unique',
              desc: '76% DMG/s for 5s', dot: { tickPercent: 76, interval: 1, duration: 5 } },
            { id: 4,  name: 'Thorn Thicket',      cd: 8,  dmgPercent: 265,   rarity: 'Unique',
              desc: '53% DMG/s + 40% slow for 5s', dot: { tickPercent: 53, interval: 1, duration: 5 },
              enemyDebuff: { stat: 'atkSpd', mult: 0.6, duration: 5 } },
            { id: 5,  name: 'Lead the Charge',    cd: 14, dmgPercent: 438,   rarity: 'Unique',
              desc: '438% DMG, +30% Basic ATK DMG 5s', selfBuff: { stat: 'basicATKMult', addPercent: 30, duration: 5 } },
            { id: 6,  name: 'Entangling Vines',   cd: 8,  dmgPercent: 394,   rarity: 'Well',
              desc: '394% DMG + 1s imprison' },
            { id: 7,  name: 'Speed Surge',        cd: 14, dmgPercent: 656,   rarity: 'Well',
              desc: '656% DMG, +30% ATK SPD 5s', selfBuff: { stat: 'atkSpd', mult: 1.3, duration: 5 } },
            { id: 8,  name: 'Spider Weaver',      cd: 10, dmgPercent: 480,   rarity: 'Well',
              desc: '96% AoE DMG/s for 5s', dot: { tickPercent: 96, interval: 1, duration: 5 } },
            { id: 9,  name: 'Pineapple Plunge',   cd: 11, dmgPercent: 985,   hits: 5, rarity: 'Rare',
              desc: '5 hits, each 197% AoE DMG' },
            { id: 10, name: 'Pearl Release',      cd: 11, dmgPercent: 789,   rarity: 'Rare',
              desc: '789% AoE DMG + 40% slow 5s', enemyDebuff: { stat: 'atkSpd', mult: 0.6, duration: 5 } },
            { id: 11, name: 'Sprawling Vine',     cd: 11, dmgPercent: 789,   rarity: 'Rare',
              desc: '789% AoE DMG + 1s imprison' },
            { id: 12, name: 'Batty Trace',        cd: 15, dmgPercent: 1575,  rarity: 'Mythic',
              desc: '315% AoE DMG/s for 5s', dot: { tickPercent: 315, interval: 1, duration: 5 } },
            { id: 13, name: "Nature's Renewal",   cd: 25, dmgPercent: 1775,  rarity: 'Mythic',
              desc: '1775% DMG, heal 30% max HP over 5s', heal: { percent: 30, duration: 5 } },
            { id: 14, name: 'Shroom Shield',      cd: 19, dmgPercent: 1183,  rarity: 'Mythic',
              desc: '1183% DMG, shield 20% max HP 10s', shield: { percent: 20, duration: 10 } },
            { id: 15, name: 'Durian Bomb',        cd: 18, dmgPercent: 2664,  hits: 3, rarity: 'Epic',
              desc: '3 hits 888% AoE DMG + 40% slow 5s', enemyDebuff: { stat: 'atkSpd', mult: 0.6, duration: 5 } },
            { id: 16, name: 'Easy Breezy',        cd: 15, dmgPercent: 1657,  rarity: 'Epic',
              desc: '1657% AoE DMG, enemy -20% ATK 5s', enemyDebuff: { stat: 'atk', mult: 0.8, duration: 5 } },
            { id: 17, name: 'Take It Slow',       cd: 12, dmgPercent: 1635,  rarity: 'Epic',
              desc: '1635% AoE DMG, enemy -40% ATK SPD 5s', enemyDebuff: { stat: 'atkSpd', mult: 0.6, duration: 5 } },
            { id: 18, name: 'Coin Bomb',          cd: 13, dmgPercent: 1450,  rarity: 'Epic',
              desc: '1450% AoE DMG, +35% Basic ATK DMG 5s', selfBuff: { stat: 'basicATKMult', addPercent: 35, duration: 5 } },
            { id: 19, name: 'Slime Bomb',         cd: 13, dmgPercent: 1450,  rarity: 'Epic',
              desc: '1450% AoE DMG, +30% Pal DMG 5s', selfBuff: { stat: 'palDMG', addPercent: 30, duration: 5 } },
            { id: 20, name: 'Meteor Fall',        cd: 13, dmgPercent: 1450,  rarity: 'Epic',
              desc: '1450% AoE DMG, +30% Skill DMG 5s', selfBuff: { stat: 'skillDMG', addPercent: 30, duration: 5 } },
            { id: 21, name: 'Disarm',             cd: 16, dmgPercent: 2682,  rarity: 'Legendary',
              desc: '2682% AoE DMG, disarm 3s', cc: { type: 'disarm', duration: 3 } },
            { id: 22, name: 'Dazzled',            cd: 19, dmgPercent: 3134,  rarity: 'Legendary',
              desc: '3134% AoE DMG, stun 1.5s', cc: { type: 'stun', duration: 1.5 } },
            { id: 23, name: 'Smoke Bomb',         cd: 13, dmgPercent: 2176,  rarity: 'Legendary',
              desc: '2176% AoE DMG, enemy +30% DMG taken 5s', enemyDebuff: { stat: 'dmgTaken', addPercent: 30, duration: 5 } },
            { id: 24, name: 'Grim Reaper',        cd: 9,  dmgPercent: 1443,  rarity: 'Legendary',
              desc: '1443% DMG, instant kill <5% HP', execute: { threshold: 5 } },
            { id: 26, name: 'Wild Gust',          cd: 16, dmgPercent: 2642,  rarity: 'Legendary',
              desc: '2642% AoE DMG, +15% ATK 5s', selfBuff: { stat: 'atk', mult: 1.15, duration: 5 } },
            { id: 27, name: 'Blitz Assault',      cd: 24, dmgPercent: 5829,  rarity: 'Immortal',
              desc: '5829% DMG, 3s DMG immunity', immunity: { duration: 3 } },
            { id: 28, name: 'Blade Pierce',       cd: 19, dmgPercent: 4663,  rarity: 'Immortal',
              desc: '4663% DMG, 1.5% target max HP/s 5s', hpDot: { percent: 1.5, interval: 1, duration: 5, isMaxHP: true, source: 'target' } },
            { id: 29, name: 'Clone Strike',       cd: 29, dmgPercent: 0,     rarity: 'Immortal',
              desc: 'Clone 30% HP, 200% basic ATK, 10s', clone: { hpPercent: 30, dmgPercent: 200, duration: 10 } },
            { id: 30, name: 'Hundred Slashes',    cd: 19, dmgPercent: 4663,  rarity: 'Immortal',
              desc: '4663% DMG, +20% BasicATK RES + 0.5% ATK of cur HP 5s', exclusive: true,
              selfBuff: { stat: 'basicATKRES', addPercent: 20, duration: 5 },
              selfBuff2: { stat: 'atk', hpPercent: 0.5, duration: 5 } },
            { id: 31, name: 'Windborne Arrow',    cd: 19, dmgPercent: 2665,  rarity: 'Immortal',
              desc: '2665% DMG, vulnerability 5s: non-skill DMG echoes +100%', exclusive: true,
              enemyDebuff: { stat: 'vulnerability', echoPct: 100, duration: 5 } },
            { id: 32, name: 'Crimson Moonfall',   cd: 8,  dmgPercent: 2098,  rarity: 'Immortal',
              desc: '2098% DMG, +50% per cast (max 3 stacks)', exclusive: true,
              stacking: { bonusPercent: 50, maxStacks: 3 } },
            { id: 33, name: 'Dragonic Resonance', cd: 15, dmgPercent: 3731,  rarity: 'Immortal',
              desc: '3731% DMG + 2% target max HP + 1% per 10% DMGRES', exclusive: true,
              hpBurst: { basePercent: 2, perDmgResPercent: 1, per: 10, source: 'target' } },
            { id: 34, name: 'Worldly Snare',      cd: 24, dmgPercent: 5413,  rarity: 'Immortal',
              desc: '5413% DMG, +10% Crit Rate, per 1% Crit ‚Üí +3% CritDMG 5s', exclusive: true,
              selfBuff: { stat: 'critScaling', critRateBonus: 10, critDmgPer1Pct: 3, duration: 5 } },
            { id: 35, name: 'Star Array',         cd: 19, dmgPercent: 4330,  rarity: 'Immortal',
              desc: '4330% DMG, +10% Skill Crit, per 1% ‚Üí +3% SkillCritDMG 5s', exclusive: true,
              selfBuff: { stat: 'skillCritScaling', skillCritBonus: 10, skillCritDmgPer1Pct: 3, duration: 5 } },
            { id: 36, name: 'Winged Dreams',      cd: 24, dmgPercent: 5413,  rarity: 'Immortal',
              desc: '5413% DMG, pals +20% Combo, per 1% ‚Üí +0.5% Pal ComboMult 5s', exclusive: true,
              selfBuff: { stat: 'palComboScaling', duration: 5 } },
            { id: 37, name: 'Ancestral Will',     cd: 24, dmgPercent: 5413,  rarity: 'Immortal',
              desc: '5413% DMG, pals +10% Crit, per 1% ‚Üí +5% Pal CritDMG 5s', exclusive: true,
              selfBuff: { stat: 'palCritScaling', duration: 5 } }
        ];

        let hpChart = null;

        // ============================================
        // UI FUNCTIONS
        // ============================================

        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.getElementById('tab-' + tabName).classList.add('active');
            event.target.classList.add('active');
        }

        function toggleCollapse(id) {
            const el = document.getElementById(id);
            const title = el.previousElementSibling;
            el.classList.toggle('collapsed');
            title.classList.toggle('collapsed');
        }

        function onAvianChange(prefix) {
            const sel = document.getElementById(prefix + 'Avian').value;
            const avian = AVIANS[sel] || AVIANS.none;
            if (avian.type === 'timed') {
                document.getElementById(prefix + 'AvianHPPercent').value = avian.hpPercent;
                document.getElementById(prefix + 'AvianInterval').value = avian.interval;
            } else if (avian.type === 'healcount') {
                document.getElementById(prefix + 'AvianHPPercent').value = avian.hpPercent;
                document.getElementById(prefix + 'AvianInterval').value = avian.healThreshold;
            } else {
                document.getElementById(prefix + 'AvianHPPercent').value = 0;
                document.getElementById(prefix + 'AvianInterval').value = 0;
            }
        }

        // Build skill slot UI (called on page load)
        function buildSkillSlots() {
            ['player', 'enemy'].forEach(prefix => {
                const container = document.getElementById(prefix + 'SkillSlots');
                let html = '';
                for (let i = 0; i < 5; i++) {
                    const sid = `${prefix}Skill${i}`;
                    html += `<div style="margin-bottom:8px;display:flex;align-items:center;gap:8px;flex-wrap:wrap;">`;
                    html += `<span style="min-width:18px;font-weight:bold;color:#aaa;">${i+1}.</span>`;
                    html += `<select id="${sid}" onchange="onSkillSlotChange('${prefix}',${i})" style="flex:1;min-width:160px;">`;
                    html += `<option value="">‚Äî None ‚Äî</option>`;
                    ACTIVE_SKILLS.forEach(sk => {
                        html += `<option value="${sk.id}">${sk.name} (${sk.cd}s) [${sk.rarity}]</option>`;
                    });
                    html += `</select>`;
                    html += `<label style="font-size:0.8em;white-space:nowrap;"><input type="checkbox" id="${sid}Custom" onchange="onSkillSlotChange('${prefix}',${i})"> Custom</label>`;
                    html += `<input type="number" id="${sid}Dmg" style="width:80px;display:none;" step="100" min="0" placeholder="DMG%">`;
                    html += `<span id="${sid}Desc" style="font-size:0.75em;color:#999;width:100%;margin-left:26px;"></span>`;
                    html += `</div>`;
                }
                container.innerHTML = html;
            });
        }

        function onSkillSlotChange(prefix, slot) {
            const sid = `${prefix}Skill${slot}`;
            const selVal = document.getElementById(sid).value;
            const isCustom = document.getElementById(sid + 'Custom').checked;
            const dmgInput = document.getElementById(sid + 'Dmg');
            const descEl = document.getElementById(sid + 'Desc');

            if (selVal === '') {
                dmgInput.style.display = 'none';
                descEl.textContent = '';
                return;
            }

            const skill = ACTIVE_SKILLS.find(s => s.id === parseInt(selVal));
            if (!skill) return;

            dmgInput.style.display = isCustom ? 'inline-block' : 'none';
            if (!isCustom) dmgInput.value = '';
            descEl.textContent = skill.desc;
        }

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        function formatNumber(num) {
            if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';
            if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
            return num.toFixed(0);
        }

        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }

        function roll(percent) {
            return Math.random() * 100 < percent;
        }

        // ============================================
        // GATHER STATS
        // ============================================

        function gatherStats(prefix) {
            const stats = {
                class: document.getElementById(prefix + 'Class').value,
                level: parseInt(document.getElementById(prefix + 'Level').value),
                atk: parseFloat(document.getElementById(prefix + 'ATK').value) * 1e6,
                hp: parseFloat(document.getElementById(prefix + 'HP').value) * 1e9,
                maxHP: parseFloat(document.getElementById(prefix + 'HP').value) * 1e9,
                def: parseFloat(document.getElementById(prefix + 'DEF').value) * 1e6,
                atkSpd: parseFloat(document.getElementById(prefix + 'ATKSPD').value),
                
                basicATKMult: parseFloat(document.getElementById(prefix + 'BasicATKMult').value),
                comboMult: parseFloat(document.getElementById(prefix + 'ComboMult').value),
                counterMult: parseFloat(document.getElementById(prefix + 'CounterMult').value),
                critDMG: parseFloat(document.getElementById(prefix + 'CritDMG').value),
                skillDMG: parseFloat(document.getElementById(prefix + 'SkillDMG').value),
                skillCritDMG: parseFloat(document.getElementById(prefix + 'SkillCritDMG').value),
                palDMG: parseFloat(document.getElementById(prefix + 'PalDMG').value),
                bossDMG: parseFloat(document.getElementById(prefix + 'BossDMG').value),

                combo: clamp(parseFloat(document.getElementById(prefix + 'Combo').value), 0, 100),
                counter: clamp(parseFloat(document.getElementById(prefix + 'Counter').value), 0, 100),
                critRate: clamp(parseFloat(document.getElementById(prefix + 'CritRate').value), 0, 100),
                skillCrit: parseFloat(document.getElementById(prefix + 'SkillCrit').value),
                stun: clamp(parseFloat(document.getElementById(prefix + 'Stun').value), 0, 100),
                launch: clamp(parseFloat(document.getElementById(prefix + 'Launch').value), 0, 100),
                evasion: parseFloat(document.getElementById(prefix + 'Evasion').value),
                healingRate: parseFloat(document.getElementById(prefix + 'HealingRate').value),
                healingAmount: parseFloat(document.getElementById(prefix + 'HealingAmount').value),

                dmgRES: clamp(parseFloat(document.getElementById(prefix + 'DMGRES').value), -100, 80),
                basicATKRES: clamp(parseFloat(document.getElementById(prefix + 'BasicATKRES').value), -100, 80),
                comboRES: clamp(parseFloat(document.getElementById(prefix + 'ComboRES').value), -100, 80),
                counterRES: clamp(parseFloat(document.getElementById(prefix + 'CounterRES').value), -100, 80),
                skillRES: clamp(parseFloat(document.getElementById(prefix + 'SkillRES').value), -100, 80),
                palRES: clamp(parseFloat(document.getElementById(prefix + 'PalRES').value), -100, 80),
                bossRES: clamp(parseFloat(document.getElementById(prefix + 'BossRES').value), -100, 80),
                critRES: Math.max(50, parseFloat(document.getElementById(prefix + 'CritRES').value)),

                ignoreEvasion: parseFloat(document.getElementById(prefix + 'IgnoreEvasion').value),
                ignoreCombo: parseFloat(document.getElementById(prefix + 'IgnoreCombo').value),
                ignoreCounter: parseFloat(document.getElementById(prefix + 'IgnoreCounter').value),
                ignoreCrit: parseFloat(document.getElementById(prefix + 'IgnoreCrit').value),
                ignoreStun: parseFloat(document.getElementById(prefix + 'IgnoreStun').value),
                ignoreLaunch: parseFloat(document.getElementById(prefix + 'IgnoreLaunch').value),
                ignoreRegen: parseFloat(document.getElementById(prefix + 'IgnoreRegen').value),

                regen: parseFloat(document.getElementById(prefix + 'Regen').value),
                cdr: parseFloat(document.getElementById(prefix + 'TalentEnergyRegen').value) || 0,

                // Talents - Final (checkboxes)
                talentAscension: document.getElementById(prefix + 'TalentAscension').checked,
                talentRampage: document.getElementById(prefix + 'TalentRampage').checked,
                talentEagerMomentum: document.getElementById(prefix + 'TalentEagerMomentum').checked,
                talentGaleBarrage: document.getElementById(prefix + 'TalentGaleBarrage').checked,
                talentTemporalCompression: document.getElementById(prefix + 'TalentTemporalCompression').checked,
                talentEndlessOutburst: document.getElementById(prefix + 'TalentEndlessOutburst').checked,
                // Talents - Leveled (numeric)
                talentWound: parseFloat(document.getElementById(prefix + 'TalentWound').value) || 0,
                talentCounterRejuv: parseFloat(document.getElementById(prefix + 'TalentCounterRejuv').value) || 0,
                talentComboHealing: parseFloat(document.getElementById(prefix + 'TalentComboHealing').value) || 0,
                talentSkillRegen: parseFloat(document.getElementById(prefix + 'TalentSkillRegen').value) || 0,
                // Battle loop tracking
                temporalStacks: 0,

                hasMoonlitLonewolf: document.getElementById(prefix + 'PalWolf').checked,
                hasElectricPup: document.getElementById(prefix + 'PalPup').checked,
                hasHydrosprite: document.getElementById(prefix + 'PalHydro').checked,
                hasBDuck: document.getElementById(prefix + 'PalBDuck').checked,
                hasPuppyFervor: document.getElementById(prefix + 'PalPuppyFervor').checked,
                hasFloralPanda: document.getElementById(prefix + 'PalFloralPanda').checked,
                hasAlpacaBell: document.getElementById(prefix + 'PalAlpacaBell').checked,
                hasMellowCloud: document.getElementById(prefix + 'PalMellowCloud').checked,
                hasTreasureDragon: document.getElementById(prefix + 'PalTreasureDragon').checked,

                avian: document.getElementById(prefix + 'Avian').value,
                avianHPPercent: parseFloat(document.getElementById(prefix + 'AvianHPPercent').value),
                avianInterval: parseFloat(document.getElementById(prefix + 'AvianInterval').value),

                // Avian affixes
                affixPunchCounter: document.getElementById(prefix + 'AffixPunchCounter').checked,
                affixPunchCounterHP: parseFloat(document.getElementById(prefix + 'AffixPunchCounterHP').value),
                affixWindTear: document.getElementById(prefix + 'AffixWindTear').checked,
                affixWindTearHP: parseFloat(document.getElementById(prefix + 'AffixWindTearHP').value),
                affixRageSlash: document.getElementById(prefix + 'AffixRageSlash').checked,
                affixRageSlashATK: parseFloat(document.getElementById(prefix + 'AffixRageSlashATK').value),
                affixTerminalStrike: document.getElementById(prefix + 'AffixTerminalStrike').checked,
                affixTerminalStrikeChance: parseFloat(document.getElementById(prefix + 'AffixTerminalStrikeChance').value),
                affixNoSpeeding: document.getElementById(prefix + 'AffixNoSpeeding').checked,
                affixNoSpeedingReduce: parseFloat(document.getElementById(prefix + 'AffixNoSpeedingReduce').value),

                // Relics
                relicKite: document.getElementById(prefix + 'RelicKite').checked,
                relicFlameBook: document.getElementById(prefix + 'RelicFlameBook').checked,
                relicNecklace: document.getElementById(prefix + 'RelicNecklace').value,
                relicStatue: document.getElementById(prefix + 'RelicStatue').value,
                relicSpore: document.getElementById(prefix + 'RelicSpore').value,
                flameBookStacks: 0,

                totalDamageDealt: 0,
                healProcs: 0,
                healCount: 0, // for Deity of Purrs tracking
                shield: 0,
                rageSlashStacks: 0,
                baseATK: 0,
                woundedUntil: 0,
                woundTalentReduction: 0,

                // Active skills (5 slots)
                activeSkills: [],

                // Per-source damage tracking
                dmgBasicATK: 0,
                dmgCombo: 0,
                dmgCounter: 0,
                dmgSageClassSkillHP: 0,
                dmgPunchCounter: 0,
                dmgClassSkill: 0,
                dmgActiveSkills: 0,
                dmgWindTear: 0,
                dmgAvian: 0,
                dmgDot: 0,
                dmgHpDot: 0,
                dmgClone: 0,
                // Counts
                counterCount: 0,
                evadeCount: 0,
                comboCount: 0,
                classSkillCount: 0,
                activeSkillCount: 0,
                avianCount: 0,
                punchCounterCount: 0,
                windTearCount: 0,
                terminalStrikeCount: 0
            };

            // Read active skill slots
            for (let i = 0; i < 5; i++) {
                const sel = document.getElementById(prefix + 'Skill' + i);
                if (!sel || sel.value === '') continue;
                const skillData = ACTIVE_SKILLS.find(s => s.id === parseInt(sel.value));
                if (!skillData) continue;
                const isCustom = document.getElementById(prefix + 'Skill' + i + 'Custom').checked;
                const customDmg = parseFloat(document.getElementById(prefix + 'Skill' + i + 'Dmg').value);
                stats.activeSkills.push({
                    ...skillData,
                    dmgPercent: (isCustom && !isNaN(customDmg)) ? customDmg : skillData.dmgPercent,
                    _cd: 0, // next fire time (starts at 0 so fires immediately? no, stagger)
                    _dotEnd: 0, _dotNext: 0, _dotTickPct: 0,
                    _hpDotEnd: 0, _hpDotNext: 0,
                    _cloneEnd: 0, _cloneNextAtk: 0,
                    _moonStacks: 0
                });
            }

            stats.baseATK = stats.atk;

            if (stats.hasElectricPup) stats.counterMult += 60;
            if (stats.hasHydrosprite) stats.cdr += 25;
            if (stats.hasTreasureDragon) { stats.critDMG += 50; stats.skillCrit += 20; }

            return stats;
        }

        // ============================================
        // DAMAGE CALCULATIONS
        // ============================================

        function calcBasicATKDamage(attacker, defender, pvpFactor) {
            const atkMinusDef = Math.max(1, attacker.atk - defender.def);
            let dmg = atkMinusDef * (attacker.basicATKMult / 100);
            dmg *= (1 - defender.basicATKRES / 100);
            dmg *= (1 - defender.dmgRES / 100);
            return dmg / pvpFactor;
        }

        function calcComboDamage(attacker, defender, pvpFactor) {
            const atkMinusDef = Math.max(1, attacker.atk - defender.def);
            let dmg = atkMinusDef * (attacker.comboMult / 100);
            dmg *= (1 - defender.comboRES / 100);
            dmg *= (1 - defender.dmgRES / 100);
            return dmg / pvpFactor;
        }

        function calcCounterDamage(attacker, defender, pvpFactor) {
            const atkMinusDef = Math.max(1, attacker.atk - defender.def);
            let dmg = atkMinusDef * (attacker.counterMult / 100);
            dmg *= (1 - defender.counterRES / 100);
            dmg *= (1 - defender.dmgRES / 100);
            return dmg / pvpFactor;
        }

        function calcSkillDamage(attacker, defender, skillDmgPercent, pvpFactor) {
            const atkMinusDef = Math.max(1, attacker.atk - defender.def);
            let dmg = atkMinusDef * (skillDmgPercent / 100) * (attacker.skillDMG / 100);
            dmg *= (1 - defender.skillRES / 100);
            dmg *= (1 - defender.dmgRES / 100);
            return dmg / pvpFactor;
        }

        // HP-Based Damage Calculation (per Yuko's PDF)
        // Used for avians, artifacts, and skills that deal HP% damage
        function calcHPDamage(attacker, defender, targetHP, hpPercent, isMaxHP, pvpFactor) {
            // Step 1: Calculate raw HP damage √ó PvP factor
            let hpDmg = targetHP * (hpPercent / 100) * pvpFactor;
            
            // Step 2: Calculate basic ATK damage (no resistances, no crit) for min/max caps
            const atkMinusDef = Math.max(1, attacker.atk - defender.def);
            const basicATKDmg = atkMinusDef * (attacker.basicATKMult / 100);
            
            // Step 3: Calculate min and max caps
            const minDmg = basicATKDmg * 0.8;
            const maxMult = isMaxHP ? 100 : 50; // 100√ó for max HP, 50√ó for current HP
            const maxDmg = basicATKDmg * maxMult;
            
            // Step 4: Clamp HP damage to min/max
            let finalDmg;
            if (hpDmg <= minDmg) {
                finalDmg = minDmg;
            } else if (hpDmg >= maxDmg) {
                finalDmg = maxDmg;
            } else {
                finalDmg = hpDmg;
            }
            
            // Step 5: Divide by PvP factor for final damage
            return finalDmg / pvpFactor;
        }

        function applyCrit(baseDmg, attacker, defender) {
            const critMult = Math.max(1.5, attacker.critDMG / defender.critRES);
            return baseDmg * critMult;
        }

        // ============================================
        // BATTLE SIMULATION
        // ============================================

        function runSimulation() {
            const player = gatherStats('player');
            const enemy = gatherStats('enemy');

            // --- Pal cross-effects (affect opponent) ---
            if (player.hasMoonlitLonewolf) enemy.regen = Math.max(0, enemy.regen * 0.9);
            if (enemy.hasMoonlitLonewolf) player.regen = Math.max(0, player.regen * 0.9);
            // Floral Panda: +0.1% base regen (self)
            if (player.hasFloralPanda) player.regen += 0.1;
            if (enemy.hasFloralPanda) enemy.regen += 0.1;
            // Alpaca Bell: enemy ATK -6%
            if (player.hasAlpacaBell) enemy.atk *= 0.94;
            if (enemy.hasAlpacaBell) player.atk *= 0.94;
            // Mellow Cloud: enemy +10% ATK SPD but -15% Basic/Combo/Counter DMG
            if (player.hasMellowCloud) {
                enemy.atkSpd *= 1.1;
                enemy.basicATKMult *= 0.85;
                enemy.comboMult *= 0.85;
                enemy.counterMult *= 0.85;
            }
            if (enemy.hasMellowCloud) {
                player.atkSpd *= 1.1;
                player.basicATKMult *= 0.85;
                player.comboMult *= 0.85;
                player.counterMult *= 0.85;
            }
            // Wound talent: reduce enemy regen and healing
            if (player.talentWound > 0) {
                enemy.regen *= (1 - player.talentWound / 100);
                enemy.woundTalentReduction = player.talentWound;
            }
            if (enemy.talentWound > 0) {
                player.regen *= (1 - enemy.talentWound / 100);
                player.woundTalentReduction = enemy.talentWound;
            }

            // Update baseATK after Alpaca Bell modification
            player.baseATK = player.atk;
            enemy.baseATK = enemy.atk;

            const avgLevel = Math.floor((player.level + enemy.level) / 2);
            const pvpFactor = PVP_FACTORS[avgLevel] || 471.70;

            const DURATION = 120;
            const TIME_STEP = 0.01;
            const SAMPLE_RATE = 0.25;

            let time = 0;
            let playerNextAttack = 0;
            let enemyNextAttack = 0;

            let playerClassSkillCD = 0;
            let enemyClassSkillCD = 0;

            // Talent state variables
            let playerAsc15 = false, playerAsc30 = false, playerAsc45 = false;
            let enemyAsc15 = false, enemyAsc30 = false, enemyAsc45 = false;
            let playerRampageTriggered = false, enemyRampageTriggered = false;
            let playerEagerStacks = 0, enemyEagerStacks = 0;
            let playerEagerNext = player.talentEagerMomentum ? 3 : Infinity;
            let enemyEagerNext = enemy.talentEagerMomentum ? 3 : Infinity;
            let playerGaleStacks = 0, enemyGaleStacks = 0;
            let playerGaleNext = player.talentGaleBarrage ? 2 : Infinity;
            let enemyGaleNext = enemy.talentGaleBarrage ? 2 : Infinity;
            let playerOutburstTriggered = false, enemyOutburstTriggered = false;
            let playerOutburstUntil = 0, enemyOutburstUntil = 0;

            // Relic state
            const playerPotentMult = player.relicSpore === 'potent' ? 1.4 : 1.0;
            const enemyPotentMult = enemy.relicSpore === 'potent' ? 1.4 : 1.0;
            let playerFlameBookNext = player.relicFlameBook ? 1 : Infinity;
            let enemyFlameBookNext = enemy.relicFlameBook ? 1 : Infinity;
            // Compute Abyss Necklace boosted skill IDs (CDR bonus)
            const ABYSS_SKILL_IDS = [33, 31, 32, 36]; // Dragonic Res, Windborne Arrow, Crimson Moonfall, Winged Dreams
            const ENERGY_STATUE_IDS = [12, 13, 14]; // Batty Trace, Nature's Renewal, Shroom Shield
            const CAGE_STATUE_IDS = [15, 16, 17]; // Durian Bomb, Easy Breezy, Take It Slow
            const CRYSTAL_STATUE_IDS = [18, 19, 20]; // Coin Bomb, Slime Bomb, Meteor Fall
            const TIME_STATUE_IDS = [21, 22, 23]; // Disarm, Dazzled, Smoke Bomb
            const STELLAR_STATUE_IDS = [30, 34, 35, 37]; // Hundred Slashes, Worldly Snare, Star Array, Ancestral Will

            // Sacred Hunter state
            let playerBoneforgeActive = 0; // Combo RES debuff timer
            let enemyBoneforgeActive = 0;
            let playerCritATKBoostUntil = 0; // Hunter passive: ATK +40% after crit
            let enemyCritATKBoostUntil = 0;

            let playerNextRegen = 5;
            let playerNextShield = 10;
            let playerShieldExpires = 0;
            let enemyNextRegen = 5;
            let enemyNextShield = 10;
            let enemyShieldExpires = 0;

            let playerBladesReunionActive = 0;
            let enemyBladesReunionActive = 0;

            // Blades Reunion counter RES debuff tracking
            let playerCounterRESDebuff = 0; // time when debuff expires on player
            let enemyCounterRESDebuff = 0;  // time when debuff expires on enemy

            // Avian setup using user-editable values
            const playerAvianType = (AVIANS[player.avian] || AVIANS.none).type;
            const enemyAvianType = (AVIANS[enemy.avian] || AVIANS.none).type;
            // Bee (timed): interval = seconds between procs
            // Deity (healcount): interval = heal count threshold
            let playerNextAvian = (playerAvianType === 'timed' && player.avianHPPercent > 0) ? player.avianInterval : Infinity;
            let enemyNextAvian = (enemyAvianType === 'timed' && enemy.avianHPPercent > 0) ? enemy.avianInterval : Infinity;

            // No Speeding: reduce enemy active skill buff durations
            const playerNoSpeedingMult = enemy.affixNoSpeeding ? (1 - enemy.affixNoSpeedingReduce / 100) : 1;
            const enemyNoSpeedingMult = player.affixNoSpeeding ? (1 - player.affixNoSpeedingReduce / 100) : 1;

            // Rage Slash: ATK stacking timer (once per second when >50% HP)
            let playerNextRageSlash = player.affixRageSlash ? 1 : Infinity;
            let enemyNextRageSlash = enemy.affixRageSlash ? 1 : Infinity;

            // CC state: stun/disarm prevent basic attacks (but not counters or skills)
            let playerCCUntil = 0; // player can't basic attack until this time
            let enemyCCUntil = 0;

            // Immunity state
            let playerImmuneUntil = 0;
            let enemyImmuneUntil = 0;

            // Vulnerability debuff (Windborne Arrow): non-skill DMG echoes extra %
            let playerVulnUntil = 0;
            let playerVulnEcho = 0;
            let enemyVulnUntil = 0;
            let enemyVulnEcho = 0;

            // DMG taken debuff (Smoke Bomb)
            let playerDmgTakenUntil = 0;
            let playerDmgTakenAdd = 0;
            let enemyDmgTakenUntil = 0;
            let enemyDmgTakenAdd = 0;

            // Active buff/debuff tracking for stat restoration
            const playerBuffs = [];
            const enemyBuffs = [];

            // Initialize active skill cooldowns: all fire near t=0, Blitz Assault (27) first
            function initSkillCDs(skills) {
                let t = 0;
                // Blitz Assault first
                skills.forEach(sk => { if (sk.id === 27) { sk._cd = t; t += 0.01; } });
                // Remaining in slot order
                skills.forEach(sk => { if (sk.id !== 27) { sk._cd = t; t += 0.01; } });
                return t;
            }
            const playerClassDelay = initSkillCDs(player.activeSkills);
            const enemyClassDelay = initSkillCDs(enemy.activeSkills);
            // Class skill fires last (after all active skills)
            playerClassSkillCD = playerClassDelay;
            enemyClassSkillCD = enemyClassDelay;

            // General regen timing (ticks every 1s)
            let playerNextGeneralRegen = 1;
            let enemyNextGeneralRegen = 1;

            const battleLog = [];
            let winner = null;

            const hpHistory = {
                times: [], playerHP: [], enemyHP: [],
                playerCDR: [], enemyCDR: [], playerATK: [], enemyATK: []
            };
            const skillEvents = { player: [], enemy: [] };
            let lastSampleTime = -1;

            function log(msg, type = '') {
                battleLog.push({ time: time.toFixed(2), msg, type });
            }

            function sampleHP() {
                if (time - lastSampleTime >= SAMPLE_RATE) {
                    hpHistory.times.push(time.toFixed(1));
                    hpHistory.playerHP.push((player.hp / player.maxHP * 100).toFixed(1));
                    hpHistory.enemyHP.push((enemy.hp / enemy.maxHP * 100).toFixed(1));
                    // Effective CDR: base CDR + outburst doubling
                    const pCDR = (1 - (1 - player.cdr / 100) * (playerOutburstUntil > time ? 0.5 : 1)) * 100;
                    const eCDR = (1 - (1 - enemy.cdr / 100) * (enemyOutburstUntil > time ? 0.5 : 1)) * 100;
                    hpHistory.playerCDR.push(pCDR.toFixed(1));
                    hpHistory.enemyCDR.push(eCDR.toFixed(1));
                    // ATK as % of base
                    hpHistory.playerATK.push((player.atk / player.baseATK * 100).toFixed(1));
                    hpHistory.enemyATK.push((enemy.atk / enemy.baseATK * 100).toFixed(1));
                    lastSampleTime = time;
                }
            }

            function dealDamage(target, amount, isTargetPlayer) {
                // Immunity check
                const immuneUntil = isTargetPlayer ? playerImmuneUntil : enemyImmuneUntil;
                if (immuneUntil > time) return { total: 0, shielded: 0 };

                // DMG taken debuff (Smoke Bomb)
                const dmgTakenUntil = isTargetPlayer ? playerDmgTakenUntil : enemyDmgTakenUntil;
                const dmgTakenAdd = isTargetPlayer ? playerDmgTakenAdd : enemyDmgTakenAdd;
                if (dmgTakenUntil > time) amount *= (1 + dmgTakenAdd / 100);

                const originalAmount = amount;
                let shieldAbsorbed = 0;

                if (target.shield > 0) {
                    if (amount <= target.shield) {
                        target.shield -= amount;
                        shieldAbsorbed = amount;
                        amount = 0;
                    } else {
                        shieldAbsorbed = target.shield;
                        amount -= target.shield;
                        target.shield = 0;
                    }
                }

                target.hp = Math.max(0, target.hp - amount);
                
                // Return object with details for logging
                return { 
                    dealt: amount, 
                    shielded: shieldAbsorbed,
                    total: originalAmount 
                };
            }

            function heal(target, amount) {
                amount *= PVP_HEALING_REDUCTION;
                // Wound talent: permanent healing reduction
                if (target.woundTalentReduction > 0) {
                    amount *= (1 - target.woundTalentReduction / 100);
                }
                // Terminal Strike wound: -50% regen/healing
                if (target.woundedUntil > time) {
                    amount *= 0.5;
                }
                const healed = Math.min(amount, target.maxHP - target.hp);
                target.hp += healed;
                target.healProcs++;
                target.healCount++;
                return healed;
            }

            sampleHP();

            while (time < DURATION && player.hp > 0 && enemy.hp > 0) {

                // === TALENT TICKS ===
                // Ascension: timed buffs at 15s, 30s, 45s
                if (player.talentAscension) {
                    if (!playerAsc15 && time >= 15) { playerAsc15 = true; player.atkSpd *= 1.15; log('[Talent] Player Ascension: ATK SPD +15%', 'buff'); }
                    if (!playerAsc30 && time >= 30) { playerAsc30 = true; player.critRate += 20; log('[Talent] Player Ascension: Crit Rate +20%', 'buff'); }
                    if (!playerAsc45 && time >= 45) { playerAsc45 = true; player.atk *= 1.20; log('[Talent] Player Ascension: ATK +20%', 'buff'); }
                }
                if (enemy.talentAscension) {
                    if (!enemyAsc15 && time >= 15) { enemyAsc15 = true; enemy.atkSpd *= 1.15; log('[Talent] Enemy Ascension: ATK SPD +15%', 'buff'); }
                    if (!enemyAsc30 && time >= 30) { enemyAsc30 = true; enemy.critRate += 20; log('[Talent] Enemy Ascension: Crit Rate +20%', 'buff'); }
                    if (!enemyAsc45 && time >= 45) { enemyAsc45 = true; enemy.atk *= 1.20; log('[Talent] Enemy Ascension: ATK +20%', 'buff'); }
                }
                // Rampage: HP < 20% triggers ATK +10%, ATK SPD +10%, Crit DMG +10%
                if (player.talentRampage && !playerRampageTriggered && player.hp / player.maxHP < 0.20) {
                    playerRampageTriggered = true;
                    player.atk *= 1.10; player.atkSpd *= 1.10; player.critDMG += 10;
                    log('[Talent] Player Rampage: ATK +10%, ATK SPD +10%, Crit DMG +10%', 'buff');
                }
                if (enemy.talentRampage && !enemyRampageTriggered && enemy.hp / enemy.maxHP < 0.20) {
                    enemyRampageTriggered = true;
                    enemy.atk *= 1.10; enemy.atkSpd *= 1.10; enemy.critDMG += 10;
                    log('[Talent] Enemy Rampage: ATK +10%, ATK SPD +10%, Crit DMG +10%', 'buff');
                }
                // Eager Momentum: every 3s, Crit DMG +5% (up to 25%)
                if (time >= playerEagerNext && playerEagerStacks < 5) {
                    playerEagerStacks++; player.critDMG += 5;
                    playerEagerNext = time + 3;
                    log(`[Talent] Player Eager Momentum: Crit DMG +5% (${playerEagerStacks * 5}% total)`, 'buff');
                }
                if (time >= enemyEagerNext && enemyEagerStacks < 5) {
                    enemyEagerStacks++; enemy.critDMG += 5;
                    enemyEagerNext = time + 3;
                    log(`[Talent] Enemy Eager Momentum: Crit DMG +5% (${enemyEagerStacks * 5}% total)`, 'buff');
                }
                // Gale Barrage: every 2s, Combo DMG +5% (up to 50%)
                if (time >= playerGaleNext && playerGaleStacks < 10) {
                    playerGaleStacks++; player.comboMult += 5;
                    playerGaleNext = time + 2;
                    log(`[Talent] Player Gale Barrage: Combo DMG +5% (${playerGaleStacks * 5}% total)`, 'buff');
                }
                if (time >= enemyGaleNext && enemyGaleStacks < 10) {
                    enemyGaleStacks++; enemy.comboMult += 5;
                    enemyGaleNext = time + 2;
                    log(`[Talent] Enemy Gale Barrage: Combo DMG +5% (${enemyGaleStacks * 5}% total)`, 'buff');
                }
                // Endless Outburst: first time HP < 20%, Energy Regen +100% for 5s
                if (player.talentEndlessOutburst && !playerOutburstTriggered && player.hp / player.maxHP < 0.20) {
                    playerOutburstTriggered = true; playerOutburstUntil = time + 5;
                    log('[Talent] Player Endless Outburst: Energy Regen +100% for 5s', 'buff');
                }
                if (enemy.talentEndlessOutburst && !enemyOutburstTriggered && enemy.hp / enemy.maxHP < 0.20) {
                    enemyOutburstTriggered = true; enemyOutburstUntil = time + 5;
                    log('[Talent] Enemy Endless Outburst: Energy Regen +100% for 5s', 'buff');
                }

                // === RELIC TICKS ===
                // Flame Book: ATK +1%/s up to 10%
                if (time >= playerFlameBookNext && player.flameBookStacks < 10) {
                    player.flameBookStacks++;
                    const pct = 1 * playerPotentMult;
                    player.atk = player.baseATK * (1 + player.flameBookStacks * pct / 100 + player.temporalStacks * 0.02);
                    playerFlameBookNext = time + 1;
                    log(`[Relic] Player Flame Book: ATK +${pct.toFixed(1)}% (${(player.flameBookStacks * pct).toFixed(1)}% total)`, 'buff');
                }
                if (time >= enemyFlameBookNext && enemy.flameBookStacks < 10) {
                    enemy.flameBookStacks++;
                    const pct = 1 * enemyPotentMult;
                    enemy.atk = enemy.baseATK * (1 + enemy.flameBookStacks * pct / 100 + enemy.temporalStacks * 0.02);
                    enemyFlameBookNext = time + 1;
                    log(`[Relic] Enemy Flame Book: ATK +${pct.toFixed(1)}% (${(enemy.flameBookStacks * pct).toFixed(1)}% total)`, 'buff');
                }

                // Hunter passive: expire crit ATK boost
                if (playerCritATKBoostUntil > 0 && playerCritATKBoostUntil <= time) {
                    player.atk /= 1.40; playerCritATKBoostUntil = 0;
                }
                if (enemyCritATKBoostUntil > 0 && enemyCritATKBoostUntil <= time) {
                    enemy.atk /= 1.40; enemyCritATKBoostUntil = 0;
                }

                // Player attacks (skip basic ATK if stunned/disarmed; counters still work)
                if (time >= playerNextAttack) {
                    const interval = 1 / player.atkSpd;
                    playerNextAttack = time + interval;

                  if (playerCCUntil <= time) {
                    const effectiveEvasion = Math.max(0, enemy.evasion - player.ignoreEvasion);
                    const evasionChance = Math.pow(effectiveEvasion / 100, 0.9) * 100;

                    if (!roll(evasionChance)) {
                        let dmg = calcBasicATKDamage(player, enemy, pvpFactor);
                        // Spirit Necklace: basic ATK +15% during Blitz Assault immunity
                        if (player.relicNecklace === 'spirit' && playerImmuneUntil > time) {
                            dmg *= (1 + 0.15 * playerPotentMult);
                        }
                        const isCrit = roll(player.critRate - enemy.ignoreCrit);
                        if (isCrit) dmg = applyCrit(dmg, player, enemy);
                        const result = dealDamage(enemy, dmg);
                        player.totalDamageDealt += result.total;
                        player.dmgBasicATK += result.total;
                        const sn = result.shielded > 0 ? ` (${formatNumber(result.shielded)} blocked)` : '';
                        log(`Player Basic ATK: ${formatNumber(result.total)}${sn}${isCrit ? ' CRIT!' : ''}`, isCrit ? 'crit' : 'damage');

                        // Hunter passive 1: basic ATK deals 1% target current HP
                        if (player.class === 'hunter') {
                            const hpDmg = calcHPDamage(player, enemy, enemy.hp, 1, false, pvpFactor);
                            const hpRes = dealDamage(enemy, hpDmg);
                            player.totalDamageDealt += hpRes.total;
                            player.dmgBasicATK += hpRes.total;
                            if (hpRes.total > 0) log(`  ‚Üí Hunter HP DMG: ${formatNumber(hpRes.total)} [1% Cur HP]`, 'damage');
                        }
                        // Hunter passive 2: after crit, ATK +40% for 1s
                        if (isCrit && player.class === 'hunter') {
                            if (playerCritATKBoostUntil <= time) player.atk *= 1.40;
                            playerCritATKBoostUntil = time + 1;
                        }

                        // Terminal Strike: chance to wound target
                        if (player.affixTerminalStrike && roll(player.affixTerminalStrikeChance)) {
                            enemy.woundedUntil = time + 1;
                            player.terminalStrikeCount++;
                            log(`  ‚Üí Terminal Strike! Enemy wounded (heal -50% for 1s)`, 'damage');
                        }

                        const effectiveCombo = Math.max(0, player.combo - enemy.ignoreCombo);
                        if (roll(effectiveCombo)) {
                            const savedEnemyComboRES = enemy.comboRES;
                            if (playerBoneforgeActive > time) {
                                enemy.comboRES = clamp(enemy.comboRES - 40, -100, 80);
                            }
                            let comboDmg = calcComboDamage(player, enemy, pvpFactor);
                            enemy.comboRES = savedEnemyComboRES;
                            const comboCrit = roll(player.critRate - enemy.ignoreCrit);
                            if (comboCrit) comboDmg = applyCrit(comboDmg, player, enemy);
                            const comboResult = dealDamage(enemy, comboDmg);
                            player.totalDamageDealt += comboResult.total;
                            player.dmgCombo += comboResult.total;
                            player.comboCount++;
                            const csn = comboResult.shielded > 0 ? ` (${formatNumber(comboResult.shielded)} blocked)` : '';
                            const bfn = playerBoneforgeActive > time ? ' [ComboRES-40%]' : '';
                            log(`  ‚Üí Combo: ${formatNumber(comboResult.total)}${csn}${comboCrit ? ' CRIT!' : ''}${bfn}`, comboCrit ? 'crit' : 'damage');
                            // Combo Healing talent
                            if (player.talentComboHealing > 0 && player.comboCount % 5 === 0) {
                                const healed = heal(player, player.maxHP * (player.talentComboHealing / 100));
                                if (healed > 0) log(`  ‚Üí Player Combo Heal: ${formatNumber(healed)}`, 'heal');
                            }
                        }
                    } else {
                        enemy.evadeCount++;
                        log(`Player Basic ATK: EVADED`, 'damage');
                    }
                  } // end CC check for player basic ATK

                    const effectiveCounter = Math.max(0, enemy.counter - player.ignoreCounter);
                    if (roll(effectiveCounter)) {
                        enemy.counterCount++;
                        const savedPlayerCounterRES = player.counterRES;
                        if (playerCounterRESDebuff > time) {
                            player.counterRES = clamp(player.counterRES - 40, -100, 80);
                        }
                        let counterDmg = calcCounterDamage(enemy, player, pvpFactor);
                        player.counterRES = savedPlayerCounterRES;
                        const counterCrit = roll(enemy.critRate - player.ignoreCrit);
                        if (counterCrit) counterDmg = applyCrit(counterDmg, enemy, player);
                        const counterResult = dealDamage(player, counterDmg, true);
                        enemy.totalDamageDealt += counterResult.total;
                        enemy.dmgCounter += counterResult.total;
                        const csn = counterResult.shielded > 0 ? ` (${formatNumber(counterResult.shielded)} blocked)` : '';
                        const dn = playerCounterRESDebuff > time ? ' [RES-40%]' : '';
                        log(`  ‚Üê Enemy Counter: ${formatNumber(counterResult.total)}${csn}${counterCrit ? ' CRIT!' : ''}${dn}`, counterCrit ? 'crit' : 'damage');

                        // Sage class skill: +1% HP counter bonus (separate log)
                        if (enemyBladesReunionActive > time) {
                            const hpBonusDmg = calcHPDamage(enemy, player, enemy.hp, 1, false, pvpFactor);
                            const hpResult = dealDamage(player, hpBonusDmg, true);
                            enemy.totalDamageDealt += hpResult.total;
                            enemy.dmgSageClassSkillHP += hpResult.total;
                            log(`  ‚Üê Enemy Sage Class Skill HP: ${formatNumber(hpResult.total)} [1% Cur HP]`, 'damage');
                        }

                        // Punch Counter affix (separate log)
                        if (enemy.affixPunchCounter && roll(50)) {
                            const pcDmg = calcHPDamage(enemy, player, enemy.hp, enemy.affixPunchCounterHP, false, pvpFactor);
                            const pcResult = dealDamage(player, pcDmg, true);
                            enemy.totalDamageDealt += pcResult.total;
                            enemy.dmgPunchCounter += pcResult.total;
                            enemy.punchCounterCount++;
                            log(`  ‚Üê Enemy Punch Counter: ${formatNumber(pcResult.total)} [${enemy.affixPunchCounterHP}% Cur HP]`, 'damage');
                        }

                        if (enemy.hasElectricPup) {
                            const lostHP = enemy.maxHP - enemy.hp;
                            const healed = heal(enemy, lostHP * 0.01);
                            if (healed > 0) log(`  ‚Üê Enemy Pup heal: ${formatNumber(healed)}`, 'heal');
                        }

                        // Counter Rejuvenation talent
                        if (enemy.talentCounterRejuv > 0 && enemy.counterCount % 5 === 0) {
                            const healed = heal(enemy, enemy.maxHP * (enemy.talentCounterRejuv / 100));
                            if (healed > 0) log(`  ‚Üê Enemy Counter Rejuv: ${formatNumber(healed)}`, 'heal');
                        }
                    }
                }

                // Enemy attacks (skip basic ATK if stunned/disarmed; counters still work)
                if (time >= enemyNextAttack) {
                    const interval = 1 / enemy.atkSpd;
                    enemyNextAttack = time + interval;

                  if (enemyCCUntil <= time) {
                    const effectiveEvasion = Math.max(0, player.evasion - enemy.ignoreEvasion);
                    const evasionChance = Math.pow(effectiveEvasion / 100, 0.9) * 100;

                    if (!roll(evasionChance)) {
                        let dmg = calcBasicATKDamage(enemy, player, pvpFactor);
                        // Spirit Necklace: basic ATK +15% during Blitz Assault immunity
                        if (enemy.relicNecklace === 'spirit' && enemyImmuneUntil > time) {
                            dmg *= (1 + 0.15 * enemyPotentMult);
                        }
                        const isCrit = roll(enemy.critRate - player.ignoreCrit);
                        if (isCrit) dmg = applyCrit(dmg, enemy, player);
                        const result = dealDamage(player, dmg, true);
                        enemy.totalDamageDealt += result.total;
                        enemy.dmgBasicATK += result.total;
                        const sn = result.shielded > 0 ? ` (${formatNumber(result.shielded)} blocked)` : '';
                        log(`Enemy Basic ATK: ${formatNumber(result.total)}${sn}${isCrit ? ' CRIT!' : ''}`, isCrit ? 'crit' : 'damage');

                        // Hunter passive 1: basic ATK deals 1% target current HP
                        if (enemy.class === 'hunter') {
                            const hpDmg = calcHPDamage(enemy, player, player.hp, 1, false, pvpFactor);
                            const hpRes = dealDamage(player, hpDmg, true);
                            enemy.totalDamageDealt += hpRes.total;
                            enemy.dmgBasicATK += hpRes.total;
                            if (hpRes.total > 0) log(`  ‚Üí Hunter HP DMG: ${formatNumber(hpRes.total)} [1% Cur HP]`, 'damage');
                        }
                        // Hunter passive 2: after crit, ATK +40% for 1s
                        if (isCrit && enemy.class === 'hunter') {
                            if (enemyCritATKBoostUntil <= time) enemy.atk *= 1.40;
                            enemyCritATKBoostUntil = time + 1;
                        }

                        if (enemy.affixTerminalStrike && roll(enemy.affixTerminalStrikeChance)) {
                            player.woundedUntil = time + 1;
                            enemy.terminalStrikeCount++;
                            log(`  ‚Üí Terminal Strike! Player wounded (heal -50% for 1s)`, 'damage');
                        }

                        const effectiveCombo = Math.max(0, enemy.combo - player.ignoreCombo);
                        if (roll(effectiveCombo)) {
                            const savedPlayerComboRES = player.comboRES;
                            if (enemyBoneforgeActive > time) {
                                player.comboRES = clamp(player.comboRES - 40, -100, 80);
                            }
                            let comboDmg = calcComboDamage(enemy, player, pvpFactor);
                            player.comboRES = savedPlayerComboRES;
                            const comboCrit = roll(enemy.critRate - player.ignoreCrit);
                            if (comboCrit) comboDmg = applyCrit(comboDmg, enemy, player);
                            const comboResult = dealDamage(player, comboDmg, true);
                            enemy.totalDamageDealt += comboResult.total;
                            enemy.dmgCombo += comboResult.total;
                            enemy.comboCount++;
                            const csn = comboResult.shielded > 0 ? ` (${formatNumber(comboResult.shielded)} blocked)` : '';
                            const bfn = enemyBoneforgeActive > time ? ' [ComboRES-40%]' : '';
                            log(`  ‚Üí Combo: ${formatNumber(comboResult.total)}${csn}${comboCrit ? ' CRIT!' : ''}${bfn}`, comboCrit ? 'crit' : 'damage');
                            // Combo Healing talent
                            if (enemy.talentComboHealing > 0 && enemy.comboCount % 5 === 0) {
                                const healed = heal(enemy, enemy.maxHP * (enemy.talentComboHealing / 100));
                                if (healed > 0) log(`  ‚Üí Enemy Combo Heal: ${formatNumber(healed)}`, 'heal');
                            }
                        }
                    } else {
                        player.evadeCount++;
                        log(`Enemy Basic ATK: EVADED`, 'damage');
                    }
                  } // end CC check for enemy basic ATK

                    const effectiveCounter = Math.max(0, player.counter - enemy.ignoreCounter);
                    if (roll(effectiveCounter)) {
                        player.counterCount++;
                        const savedEnemyCounterRES = enemy.counterRES;
                        if (enemyCounterRESDebuff > time) {
                            enemy.counterRES = clamp(enemy.counterRES - 40, -100, 80);
                        }
                        let counterDmg = calcCounterDamage(player, enemy, pvpFactor);
                        enemy.counterRES = savedEnemyCounterRES;
                        const counterCrit = roll(player.critRate - enemy.ignoreCrit);
                        if (counterCrit) counterDmg = applyCrit(counterDmg, player, enemy);
                        const counterResult = dealDamage(enemy, counterDmg);
                        player.totalDamageDealt += counterResult.total;
                        player.dmgCounter += counterResult.total;
                        const csn = counterResult.shielded > 0 ? ` (${formatNumber(counterResult.shielded)} blocked)` : '';
                        const dn = enemyCounterRESDebuff > time ? ' [RES-40%]' : '';
                        log(`  ‚Üê Player Counter: ${formatNumber(counterResult.total)}${csn}${counterCrit ? ' CRIT!' : ''}${dn}`, counterCrit ? 'crit' : 'damage');

                        // Sage class skill: +1% HP counter bonus (separate log)
                        if (playerBladesReunionActive > time) {
                            const hpBonusDmg = calcHPDamage(player, enemy, player.hp, 1, false, pvpFactor);
                            const hpResult = dealDamage(enemy, hpBonusDmg);
                            player.totalDamageDealt += hpResult.total;
                            player.dmgSageClassSkillHP += hpResult.total;
                            log(`  ‚Üê Player Sage Class Skill HP: ${formatNumber(hpResult.total)} [1% Cur HP]`, 'damage');
                        }

                        // Punch Counter affix (separate log)
                        if (player.affixPunchCounter && roll(50)) {
                            const pcDmg = calcHPDamage(player, enemy, player.hp, player.affixPunchCounterHP, false, pvpFactor);
                            const pcResult = dealDamage(enemy, pcDmg);
                            player.totalDamageDealt += pcResult.total;
                            player.dmgPunchCounter += pcResult.total;
                            player.punchCounterCount++;
                            log(`  ‚Üê Player Punch Counter: ${formatNumber(pcResult.total)} [${player.affixPunchCounterHP}% Cur HP]`, 'damage');
                        }

                        if (player.hasElectricPup) {
                            const lostHP = player.maxHP - player.hp;
                            const healed = heal(player, lostHP * 0.01);
                            if (healed > 0) log(`  ‚Üê Player Pup heal: ${formatNumber(healed)}`, 'heal');
                        }

                        // Counter Rejuvenation talent
                        if (player.talentCounterRejuv > 0 && player.counterCount % 5 === 0) {
                            const healed = heal(player, player.maxHP * (player.talentCounterRejuv / 100));
                            if (healed > 0) log(`  ‚Üê Player Counter Rejuv: ${formatNumber(healed)}`, 'heal');
                        }
                    }
                }

                // Class skills
                if (player.class === 'sage' && time >= playerClassSkillCD) {
                    const pCdMult = (1 - player.cdr / 100) * (playerOutburstUntil > time ? 0.5 : 1);
                    playerClassSkillCD = time + Math.max(1, 15 * pCdMult);
                    player.classSkillCount++;
                    const buffDur = 8 * playerNoSpeedingMult * (enemy.relicSpore === 'thorny' ? 0.80 : 1);
                    playerBladesReunionActive = time + buffDur;
                    enemyCounterRESDebuff = time + buffDur;
                    let skillDmg = calcSkillDamage(player, enemy, 12580, pvpFactor);
                    const skillCrit = roll(player.skillCrit);
                    if (skillCrit) {
                        const skillCritMult = Math.max(1.5, player.skillCritDMG / enemy.critRES);
                        skillDmg *= skillCritMult;
                    }
                    const skillResult = dealDamage(enemy, skillDmg);
                    player.totalDamageDealt += skillResult.total;
                    player.dmgClassSkill += skillResult.total;
                    const sn = skillResult.shielded > 0 ? ` (${formatNumber(skillResult.shielded)} blocked)` : '';
                    log(`Player BLADES REUNION: ${formatNumber(skillResult.total)}${sn}${skillCrit ? ' CRIT!' : ''} [Counter RES -40% ${buffDur.toFixed(1)}s]`, 'skill');
                    skillEvents.player.push({ name: 'Blades Reunion', id: 'class', start: time, end: time + buffDur });
                    if (player.affixWindTear) {
                        const wtDmg = calcHPDamage(player, enemy, enemy.hp, player.affixWindTearHP, false, pvpFactor);
                        const wtResult = dealDamage(enemy, wtDmg);
                        player.totalDamageDealt += wtResult.total;
                        player.dmgWindTear += wtResult.total;
                        player.windTearCount++;
                        log(`  ‚Üí Player Wind Tear: ${formatNumber(wtResult.total)} [${player.affixWindTearHP}% Cur HP]`, 'damage');
                    }
                }

                // Sacred Hunter: Piercing Boneforge (player)
                if (player.class === 'hunter' && time >= playerClassSkillCD) {
                    const pCdMult = (1 - player.cdr / 100) * (playerOutburstUntil > time ? 0.5 : 1);
                    playerClassSkillCD = time + Math.max(1, 15 * pCdMult);
                    player.classSkillCount++;
                    const buffDur = 8 * playerNoSpeedingMult * (enemy.relicSpore === 'thorny' ? 0.80 : 1);
                    playerBoneforgeActive = time + buffDur;
                    // Energy lock: add 4s to all enemy skill CDs
                    enemy.activeSkills.forEach(sk => { sk._cd += 4; });
                    enemyClassSkillCD += 4;
                    let skillDmg = calcSkillDamage(player, enemy, 14161, pvpFactor);
                    const skillCrit = roll(player.skillCrit);
                    if (skillCrit) {
                        const skillCritMult = Math.max(1.5, player.skillCritDMG / enemy.critRES);
                        skillDmg *= skillCritMult;
                    }
                    const skillResult = dealDamage(enemy, skillDmg);
                    player.totalDamageDealt += skillResult.total;
                    player.dmgClassSkill += skillResult.total;
                    const sn = skillResult.shielded > 0 ? ` (${formatNumber(skillResult.shielded)} blocked)` : '';
                    log(`Player PIERCING BONEFORGE: ${formatNumber(skillResult.total)}${sn}${skillCrit ? ' CRIT!' : ''} [Combo RES -40% ${buffDur.toFixed(1)}s, Energy Lock 4s]`, 'skill');
                    skillEvents.player.push({ name: 'Piercing Boneforge', id: 'class', start: time, end: time + buffDur });
                    if (player.affixWindTear) {
                        const wtDmg = calcHPDamage(player, enemy, enemy.hp, player.affixWindTearHP, false, pvpFactor);
                        const wtResult = dealDamage(enemy, wtDmg);
                        player.totalDamageDealt += wtResult.total;
                        player.dmgWindTear += wtResult.total;
                        player.windTearCount++;
                        log(`  ‚Üí Player Wind Tear: ${formatNumber(wtResult.total)} [${player.affixWindTearHP}% Cur HP]`, 'damage');
                    }
                }

                if (enemy.class === 'sage' && time >= enemyClassSkillCD) {
                    const eCdMult = (1 - enemy.cdr / 100) * (enemyOutburstUntil > time ? 0.5 : 1);
                    enemyClassSkillCD = time + Math.max(1, 15 * eCdMult);
                    enemy.classSkillCount++;
                    const buffDur = 8 * enemyNoSpeedingMult * (player.relicSpore === 'thorny' ? 0.80 : 1);
                    enemyBladesReunionActive = time + buffDur;
                    playerCounterRESDebuff = time + buffDur;
                    let skillDmg = calcSkillDamage(enemy, player, 12580, pvpFactor);
                    const skillCrit = roll(enemy.skillCrit);
                    if (skillCrit) {
                        const skillCritMult = Math.max(1.5, enemy.skillCritDMG / player.critRES);
                        skillDmg *= skillCritMult;
                    }
                    const skillResult = dealDamage(player, skillDmg, true);
                    enemy.totalDamageDealt += skillResult.total;
                    enemy.dmgClassSkill += skillResult.total;
                    const sn = skillResult.shielded > 0 ? ` (${formatNumber(skillResult.shielded)} blocked)` : '';
                    log(`Enemy BLADES REUNION: ${formatNumber(skillResult.total)}${sn}${skillCrit ? ' CRIT!' : ''} [Counter RES -40% ${buffDur.toFixed(1)}s]`, 'skill');
                    skillEvents.enemy.push({ name: 'Blades Reunion', id: 'class', start: time, end: time + buffDur });
                    if (enemy.affixWindTear) {
                        const wtDmg = calcHPDamage(enemy, player, player.hp, enemy.affixWindTearHP, false, pvpFactor);
                        const wtResult = dealDamage(player, wtDmg, true);
                        enemy.totalDamageDealt += wtResult.total;
                        enemy.dmgWindTear += wtResult.total;
                        enemy.windTearCount++;
                        log(`  ‚Üí Enemy Wind Tear: ${formatNumber(wtResult.total)} [${enemy.affixWindTearHP}% Cur HP]`, 'damage');
                    }
                }

                // Sacred Hunter: Piercing Boneforge (enemy)
                if (enemy.class === 'hunter' && time >= enemyClassSkillCD) {
                    const eCdMult = (1 - enemy.cdr / 100) * (enemyOutburstUntil > time ? 0.5 : 1);
                    enemyClassSkillCD = time + Math.max(1, 15 * eCdMult);
                    enemy.classSkillCount++;
                    const buffDur = 8 * enemyNoSpeedingMult * (player.relicSpore === 'thorny' ? 0.80 : 1);
                    enemyBoneforgeActive = time + buffDur;
                    // Energy lock: add 4s to all player skill CDs
                    player.activeSkills.forEach(sk => { sk._cd += 4; });
                    playerClassSkillCD += 4;
                    let skillDmg = calcSkillDamage(enemy, player, 14161, pvpFactor);
                    const skillCrit = roll(enemy.skillCrit);
                    if (skillCrit) {
                        const skillCritMult = Math.max(1.5, enemy.skillCritDMG / player.critRES);
                        skillDmg *= skillCritMult;
                    }
                    const skillResult = dealDamage(player, skillDmg, true);
                    enemy.totalDamageDealt += skillResult.total;
                    enemy.dmgClassSkill += skillResult.total;
                    const sn = skillResult.shielded > 0 ? ` (${formatNumber(skillResult.shielded)} blocked)` : '';
                    log(`Enemy PIERCING BONEFORGE: ${formatNumber(skillResult.total)}${sn}${skillCrit ? ' CRIT!' : ''} [Combo RES -40% ${buffDur.toFixed(1)}s, Energy Lock 4s]`, 'skill');
                    skillEvents.enemy.push({ name: 'Piercing Boneforge', id: 'class', start: time, end: time + buffDur });
                    if (enemy.affixWindTear) {
                        const wtDmg = calcHPDamage(enemy, player, player.hp, enemy.affixWindTearHP, false, pvpFactor);
                        const wtResult = dealDamage(player, wtDmg, true);
                        enemy.totalDamageDealt += wtResult.total;
                        enemy.dmgWindTear += wtResult.total;
                        enemy.windTearCount++;
                        log(`  ‚Üí Enemy Wind Tear: ${formatNumber(wtResult.total)} [${enemy.affixWindTearHP}% Cur HP]`, 'damage');
                    }
                }

                // === ACTIVE SKILLS (5 slots per side) ===
                function processActiveSkills(attacker, defender, skills, isDefenderPlayer, noSpeedMult) {
                    for (const sk of skills) {
                        // Check cooldown
                        if (time < sk._cd) continue;

                        const potMult = attacker === player ? playerPotentMult : enemyPotentMult;
                        const outburstMult = (attacker === player ? playerOutburstUntil : enemyOutburstUntil) > time ? 0.5 : 1;
                        let cdMult = (1 - attacker.cdr / 100) * outburstMult;
                        // Abyss Necklace: Energy Regen SPD +30% for specific skills
                        if (attacker.relicNecklace === 'abyss' && ABYSS_SKILL_IDS.includes(sk.id)) {
                            cdMult *= (1 - 0.30 * potMult);
                        }
                        sk._cd = time + Math.max(1, sk.cd * cdMult);
                        attacker.activeSkillCount++;

                        // Compute statue duration multiplier for buffs/debuffs/CC
                        let statDurMult = 1;
                        if (attacker.relicStatue === 'time' && TIME_STATUE_IDS.includes(sk.id)) statDurMult = 1 + 0.30 * potMult;
                        if (attacker.relicStatue === 'stellar' && STELLAR_STATUE_IDS.includes(sk.id)) statDurMult = 1 + 0.50 * potMult;

                        // --- Instant damage ---
                        let dmgPct = sk.dmgPercent;
                        // Crimson Moonfall stacking
                        if (sk.stacking) {
                            dmgPct *= (1 + sk._moonStacks * sk.stacking.bonusPercent / 100);
                            if (sk._moonStacks < sk.stacking.maxStacks) sk._moonStacks++;
                        }
                        // Necklace DMG boosts
                        if (attacker.relicNecklace === 'shield' && sk.id === 24) dmgPct *= (1 + 0.80 * potMult);
                        if (attacker.relicNecklace === 'storm' && sk.id === 29) dmgPct *= (1 + 0.30 * potMult);
                        // Statue DMG boosts
                        if (attacker.relicStatue === 'energy' && ENERGY_STATUE_IDS.includes(sk.id)) dmgPct *= (1 + 0.30 * potMult);
                        if (attacker.relicStatue === 'cage' && CAGE_STATUE_IDS.includes(sk.id)) dmgPct *= (1 + 0.30 * potMult);
                        if (attacker.relicStatue === 'crystal' && CRYSTAL_STATUE_IDS.includes(sk.id)) dmgPct *= (1 + 0.30 * potMult);
                        if (dmgPct > 0) {
                            let sDmg = calcSkillDamage(attacker, defender, dmgPct, pvpFactor);
                            const sCrit = roll(attacker.skillCrit);
                            if (sCrit) {
                                const m = Math.max(1.5, attacker.skillCritDMG / defender.critRES);
                                sDmg *= m;
                            }
                            const sRes = dealDamage(defender, sDmg, isDefenderPlayer);
                            attacker.totalDamageDealt += sRes.total;
                            attacker.dmgActiveSkills += sRes.total;
                            const sn = sRes.shielded > 0 ? ` (${formatNumber(sRes.shielded)} blocked)` : '';
                            log(`${attacker === player ? 'Player' : 'Enemy'} ${sk.name}: ${formatNumber(sRes.total)}${sn}${sCrit ? ' CRIT!' : ''}`, 'skill');
                        }

                        // --- Wind Tear on active skill ---
                        if (attacker.affixWindTear) {
                            const wtDmg = calcHPDamage(attacker, defender, defender.hp, attacker.affixWindTearHP, false, pvpFactor);
                            const wtRes = dealDamage(defender, wtDmg, isDefenderPlayer);
                            attacker.totalDamageDealt += wtRes.total;
                            attacker.dmgWindTear += wtRes.total;
                            attacker.windTearCount++;
                            log(`  ‚Üí ${attacker === player ? 'Player' : 'Enemy'} Wind Tear: ${formatNumber(wtRes.total)} [${attacker.affixWindTearHP}% Cur HP]`, 'damage');
                        }

                        const who = attacker === player ? 'Player' : 'Enemy';

                        // --- Thundercaller Kite: deal 1705% DMG after active skill ---
                        if (attacker.relicKite) {
                            const kitePct = 1705 * potMult;
                            let kiteDmg = calcSkillDamage(attacker, defender, kitePct, pvpFactor);
                            const kiteRes = dealDamage(defender, kiteDmg, isDefenderPlayer);
                            attacker.totalDamageDealt += kiteRes.total;
                            attacker.dmgActiveSkills += kiteRes.total;
                            log(`  ‚Üí ${who} Kite: ${formatNumber(kiteRes.total)} [${kitePct.toFixed(0)}%]`, 'skill');
                        }

                        // --- Crimson Sickle Necklace: heal 2.5% max HP on Blade Pierce / Wild Gust ---
                        if (attacker.relicNecklace === 'crimson' && (sk.id === 28 || sk.id === 26)) {
                            const healPct = 2.5 * potMult;
                            const healed = heal(attacker, attacker.maxHP * (healPct / 100));
                            if (healed > 0) log(`  ‚Üí ${who} Crimson Sickle heal: ${formatNumber(healed)}`, 'heal');
                        }

                        // --- Temporal Compression: ATK +2% per skill cast (max 30%) ---
                        if (attacker.talentTemporalCompression && attacker.temporalStacks < 15) {
                            attacker.temporalStacks++;
                            attacker.atk = attacker.baseATK * (1 + attacker.temporalStacks * 0.02);
                            log(`  ‚Üí ${who} Temporal Compression: ATK +2% (${attacker.temporalStacks * 2}% total)`, 'buff');
                        }

                        // --- Skill Regen talent: heal %HP per skill cast ---
                        if (attacker.talentSkillRegen > 0) {
                            const healed = heal(attacker, attacker.maxHP * (attacker.talentSkillRegen / 100));
                            if (healed > 0) log(`  ‚Üí ${who} Skill Regen: ${formatNumber(healed)}`, 'heal');
                        }

                        // --- Execute (Grim Reaper) ---
                        if (sk.execute && defender.hp > 0 && (defender.hp / defender.maxHP * 100) < sk.execute.threshold) {
                            defender.hp = 0;
                            log(`  ‚Üí ${who} Grim Reaper: INSTANT KILL (<${sk.execute.threshold}% HP)`, 'crit');
                        }

                        // --- DoT (Boulder Impact, Thorn Thicket, Spider Weaver, Batty Trace) ---
                        if (sk.dot) {
                            sk._dotEnd = time + sk.dot.duration;
                            sk._dotNext = time + sk.dot.interval;
                            sk._dotTickPct = sk.dot.tickPercent;
                        }

                        // --- HP% DoT (Blade Pierce) ---
                        if (sk.hpDot) {
                            sk._hpDotEnd = time + sk.hpDot.duration;
                            sk._hpDotNext = time + sk.hpDot.interval;
                        }

                        // --- HP Burst (Dragonic Resonance) ---
                        if (sk.hpBurst) {
                            const h = sk.hpBurst;
                            const dmgResStacks = Math.floor(defender.dmgRES / h.per);
                            const totalPct = h.basePercent + dmgResStacks * h.perDmgResPercent;
                            const hpDmg = calcHPDamage(attacker, defender, defender.maxHP, totalPct, true, pvpFactor);
                            const hpRes = dealDamage(defender, hpDmg, isDefenderPlayer);
                            attacker.totalDamageDealt += hpRes.total;
                            attacker.dmgHpDot += hpRes.total;
                            log(`  ‚Üí ${who} Dragonic HP: ${formatNumber(hpRes.total)} [${totalPct}% Max HP]`, 'damage');
                        }

                        // --- Clone (Clone Strike) ---
                        if (sk.clone) {
                            sk._cloneEnd = time + sk.clone.duration;
                            sk._cloneNextAtk = time + 1 / 3; // clone ATK SPD ~3
                            log(`  ‚Üí ${who} Clone summoned (${sk.clone.duration}s)`, 'skill');
                        }

                        // --- Self Buff ---
                        if (sk.selfBuff) {
                            const b = sk.selfBuff;
                            const dur = b.duration * noSpeedMult * statDurMult;
                            const expires = time + dur;
                            if (b.stat === 'basicATKMult' && b.addPercent) {
                                attacker.basicATKMult += b.addPercent;
                                (attacker === player ? playerBuffs : enemyBuffs).push({ expires, undo: () => { attacker.basicATKMult -= b.addPercent; }});
                            } else if (b.stat === 'atkSpd' && b.mult) {
                                const added = attacker.atkSpd * (b.mult - 1);
                                attacker.atkSpd *= b.mult;
                                (attacker === player ? playerBuffs : enemyBuffs).push({ expires, undo: () => { attacker.atkSpd /= b.mult; }});
                            } else if (b.stat === 'atk' && b.mult) {
                                attacker.atk *= b.mult;
                                (attacker === player ? playerBuffs : enemyBuffs).push({ expires, undo: () => { attacker.atk /= b.mult; }});
                            } else if (b.stat === 'palDMG' && b.addPercent) {
                                attacker.palDMG += b.addPercent;
                                (attacker === player ? playerBuffs : enemyBuffs).push({ expires, undo: () => { attacker.palDMG -= b.addPercent; }});
                            } else if (b.stat === 'skillDMG' && b.addPercent) {
                                attacker.skillDMG += b.addPercent;
                                (attacker === player ? playerBuffs : enemyBuffs).push({ expires, undo: () => { attacker.skillDMG -= b.addPercent; }});
                            } else if (b.stat === 'basicATKRES' && b.addPercent) {
                                attacker.basicATKRES += b.addPercent;
                                (attacker === player ? playerBuffs : enemyBuffs).push({ expires, undo: () => { attacker.basicATKRES -= b.addPercent; }});
                            } else if (b.stat === 'critScaling') {
                                const addedCR = b.critRateBonus;
                                const addedCD = (attacker.critRate + addedCR) * b.critDmgPer1Pct;
                                attacker.critRate += addedCR;
                                attacker.critDMG += addedCD;
                                (attacker === player ? playerBuffs : enemyBuffs).push({ expires, undo: () => { attacker.critRate -= addedCR; attacker.critDMG -= addedCD; }});
                            } else if (b.stat === 'skillCritScaling') {
                                const addedSCR = b.skillCritBonus;
                                const addedSCD = (attacker.skillCrit + addedSCR) * b.skillCritDmgPer1Pct;
                                attacker.skillCrit += addedSCR;
                                attacker.skillCritDMG += addedSCD;
                                (attacker === player ? playerBuffs : enemyBuffs).push({ expires, undo: () => { attacker.skillCrit -= addedSCR; attacker.skillCritDMG -= addedSCD; }});
                            }
                            // palComboScaling and palCritScaling are pal-specific - skip for now (no pal sim)
                        }

                        // --- Self Buff 2 (Hundred Slashes ATK% of HP) ---
                        if (sk.selfBuff2) {
                            const b2 = sk.selfBuff2;
                            const dur = b2.duration * noSpeedMult * statDurMult;
                            const atkAdd = attacker.hp * (b2.hpPercent / 100);
                            attacker.atk += atkAdd;
                            (attacker === player ? playerBuffs : enemyBuffs).push({ expires: time + dur, undo: () => { attacker.atk -= atkAdd; }});
                        }

                        // --- Enemy Debuff ---
                        if (sk.enemyDebuff) {
                            const d = sk.enemyDebuff;
                            const dur = d.duration * noSpeedMult * statDurMult;
                            if (d.stat === 'atkSpd' && d.mult) {
                                defender.atkSpd *= d.mult;
                                (isDefenderPlayer ? playerBuffs : enemyBuffs).push({ expires: time + dur, undo: () => { defender.atkSpd /= d.mult; }});
                            } else if (d.stat === 'atk' && d.mult) {
                                defender.atk *= d.mult;
                                (isDefenderPlayer ? playerBuffs : enemyBuffs).push({ expires: time + dur, undo: () => { defender.atk /= d.mult; }});
                            } else if (d.stat === 'dmgTaken' && d.addPercent) {
                                if (isDefenderPlayer) { playerDmgTakenUntil = time + dur; playerDmgTakenAdd = d.addPercent; }
                                else { enemyDmgTakenUntil = time + dur; enemyDmgTakenAdd = d.addPercent; }
                            } else if (d.stat === 'vulnerability') {
                                if (isDefenderPlayer) { playerVulnUntil = time + dur; playerVulnEcho = d.echoPct; }
                                else { enemyVulnUntil = time + dur; enemyVulnEcho = d.echoPct; }
                            }
                        }

                        // --- CC (Stun/Disarm) ---
                        if (sk.cc) {
                            const ccEnd = time + sk.cc.duration * statDurMult;
                            if (isDefenderPlayer) { playerCCUntil = Math.max(playerCCUntil, ccEnd); }
                            else { enemyCCUntil = Math.max(enemyCCUntil, ccEnd); }
                            log(`  ‚Üí ${who} ${sk.cc.type === 'stun' ? 'STUN' : 'DISARM'}: ${sk.cc.duration}s`, 'skill');
                        }

                        // --- Immunity (Blitz Assault) ---
                        if (sk.immunity) {
                            const immEnd = time + sk.immunity.duration;
                            if (attacker === player) playerImmuneUntil = Math.max(playerImmuneUntil, immEnd);
                            else enemyImmuneUntil = Math.max(enemyImmuneUntil, immEnd);
                            log(`  ‚Üí ${who} IMMUNE for ${sk.immunity.duration}s`, 'skill');
                        }

                        // --- Heal (Nature's Renewal: 30% over 5s = heal proc every 0.1s) ---
                        if (sk.heal) {
                            sk._healEnd = time + sk.heal.duration;
                            sk._healNext = time + 0.1;
                            sk._healPerTick = attacker.maxHP * (sk.heal.percent / 100) / (sk.heal.duration / 0.1);
                        }

                        // --- Shield (Shroom Shield) ---
                        if (sk.shield) {
                            let shieldAmt = attacker.maxHP * (sk.shield.percent / 100) * PVP_SHIELD_REDUCTION;
                            if (attacker.hasPuppyFervor) shieldAmt *= 1.2;
                            attacker.shield = Math.max(attacker.shield, shieldAmt);
                            const shieldDur = sk.shield.duration + (attacker.hasBDuck ? 1.5 : 0);
                            const shieldExpire = time + shieldDur;
                            if (attacker === player) playerShieldExpires = Math.max(playerShieldExpires, shieldExpire);
                            else enemyShieldExpires = Math.max(enemyShieldExpires, shieldExpire);
                            log(`  ‚Üí ${who} Shield: ${formatNumber(shieldAmt)} (${shieldDur}s)`, 'skill');
                        }

                        // Record skill event for uptime visualization
                        let effectDur = 0;
                        if (sk.dot) effectDur = Math.max(effectDur, sk.dot.duration);
                        if (sk.hpDot) effectDur = Math.max(effectDur, sk.hpDot.duration);
                        if (sk.clone) effectDur = Math.max(effectDur, sk.clone.duration);
                        if (sk.selfBuff) effectDur = Math.max(effectDur, sk.selfBuff.duration * noSpeedMult * statDurMult);
                        if (sk.selfBuff2) effectDur = Math.max(effectDur, sk.selfBuff2.duration * noSpeedMult * statDurMult);
                        if (sk.enemyDebuff) effectDur = Math.max(effectDur, sk.enemyDebuff.duration * noSpeedMult * statDurMult);
                        if (sk.cc) effectDur = Math.max(effectDur, sk.cc.duration * statDurMult);
                        if (sk.immunity) effectDur = Math.max(effectDur, sk.immunity.duration);
                        if (sk.heal) effectDur = Math.max(effectDur, sk.heal.duration);
                        if (sk.shield) effectDur = Math.max(effectDur, sk.shield.duration);
                        if (effectDur === 0) effectDur = 0.3;
                        const evts = attacker === player ? skillEvents.player : skillEvents.enemy;
                        evts.push({ name: sk.name, id: sk.id, start: time, end: time + effectDur });
                    }
                }

                // Process player active skills
                processActiveSkills(player, enemy, player.activeSkills, false, playerNoSpeedingMult);
                // Process enemy active skills
                processActiveSkills(enemy, player, enemy.activeSkills, true, enemyNoSpeedingMult);

                // === Tick DoTs, HP DoTs, Clones, Heals from active skills ===
                function tickSkillEffects(attacker, defender, skills, isDefenderPlayer) {
                    const who = attacker === player ? 'Player' : 'Enemy';
                    for (const sk of skills) {
                        // Tick DoT
                        if (sk._dotEnd > time && sk._dotNext <= time) {
                            sk._dotNext = time + (sk.dot ? sk.dot.interval : 1);
                            let dotDmg = calcSkillDamage(attacker, defender, sk._dotTickPct, pvpFactor);
                            const dotRes = dealDamage(defender, dotDmg, isDefenderPlayer);
                            attacker.totalDamageDealt += dotRes.total;
                            attacker.dmgDot += dotRes.total;
                            log(`${who} ${sk.name} DoT: ${formatNumber(dotRes.total)}`, 'damage');
                        }
                        // Tick HP% DoT (Blade Pierce)
                        if (sk.hpDot && sk._hpDotEnd > time && sk._hpDotNext <= time) {
                            sk._hpDotNext = time + sk.hpDot.interval;
                            const hpSrc = sk.hpDot.isMaxHP ? defender.maxHP : defender.hp;
                            const hpDmg = calcHPDamage(attacker, defender, hpSrc, sk.hpDot.percent, sk.hpDot.isMaxHP, pvpFactor);
                            const hpRes = dealDamage(defender, hpDmg, isDefenderPlayer);
                            attacker.totalDamageDealt += hpRes.total;
                            attacker.dmgHpDot += hpRes.total;
                            log(`${who} ${sk.name} HP DoT: ${formatNumber(hpRes.total)} [${sk.hpDot.percent}% Max HP]`, 'damage');
                        }
                        // Tick Clone
                        if (sk.clone && sk._cloneEnd > time && sk._cloneNextAtk <= time) {
                            sk._cloneNextAtk = time + 1 / 3;
                            let cloneDmg = calcSkillDamage(attacker, defender, sk.clone.dmgPercent, pvpFactor);
                            // Storm Necklace: Clone DMG +30%
                            if (attacker.relicNecklace === 'storm') {
                                const pm = attacker === player ? playerPotentMult : enemyPotentMult;
                                cloneDmg *= (1 + 0.30 * pm);
                            }
                            const cloneRes = dealDamage(defender, cloneDmg, isDefenderPlayer);
                            attacker.totalDamageDealt += cloneRes.total;
                            attacker.dmgClone += cloneRes.total;
                            log(`${who} Clone ATK: ${formatNumber(cloneRes.total)}`, 'damage');
                        }
                        // Tick Heal (Nature's Renewal)
                        if (sk.heal && sk._healEnd > time && sk._healNext <= time) {
                            sk._healNext = time + 0.1;
                            const healed = heal(attacker, sk._healPerTick);
                            if (healed > 0) log(`${who} ${sk.name} heal: ${formatNumber(healed)}`, 'heal');
                        }
                    }
                }

                tickSkillEffects(player, enemy, player.activeSkills, false);
                tickSkillEffects(enemy, player, enemy.activeSkills, true);

                // === Expire buffs/debuffs ===
                for (let i = playerBuffs.length - 1; i >= 0; i--) {
                    if (playerBuffs[i].expires <= time) { playerBuffs[i].undo(); playerBuffs.splice(i, 1); }
                }
                for (let i = enemyBuffs.length - 1; i >= 0; i--) {
                    if (enemyBuffs[i].expires <= time) { enemyBuffs[i].undo(); enemyBuffs.splice(i, 1); }
                }

                // Sage passives
                if (player.class === 'sage' && time >= playerNextRegen) {
                    playerNextRegen = time + 5;
                    const healed = heal(player, player.maxHP * 0.08);
                    log(`[Heal] Player Sage Regen: ${formatNumber(healed)}`, 'heal');
                }

                if (enemy.class === 'sage' && time >= enemyNextRegen) {
                    enemyNextRegen = time + 5;
                    const healed = heal(enemy, enemy.maxHP * 0.08);
                    log(`[Heal] Enemy Sage Regen: ${formatNumber(healed)}`, 'heal');
                }

                if (player.class === 'sage' && time >= playerNextShield) {
                    playerNextShield = time + 10;
                    let pShield = player.maxHP * 0.08 * PVP_SHIELD_REDUCTION;
                    if (player.hasPuppyFervor) pShield *= 1.2;
                    player.shield = pShield;
                    const pShieldDur = 5 + (player.hasBDuck ? 1.5 : 0);
                    playerShieldExpires = time + pShieldDur;
                    log(`[Shield] Player Sage Shield: ${formatNumber(pShield)} (${pShieldDur}s)`, 'skill');
                }

                if (enemy.class === 'sage' && time >= enemyNextShield) {
                    enemyNextShield = time + 10;
                    let eShield = enemy.maxHP * 0.08 * PVP_SHIELD_REDUCTION;
                    if (enemy.hasPuppyFervor) eShield *= 1.2;
                    enemy.shield = eShield;
                    const eShieldDur = 5 + (enemy.hasBDuck ? 1.5 : 0);
                    enemyShieldExpires = time + eShieldDur;
                    log(`[Shield] Enemy Sage Shield: ${formatNumber(eShield)} (${eShieldDur}s)`, 'skill');
                }

                // Expire shields after duration
                if (player.shield > 0 && time >= playerShieldExpires) {
                    player.shield = 0;
                }
                if (enemy.shield > 0 && time >= enemyShieldExpires) {
                    enemy.shield = 0;
                }

                // === AVIAN DAMAGE ===
                // Bee (timed): fires every N seconds
                if (playerAvianType === 'timed' && player.avianHPPercent > 0 && time >= playerNextAvian) {
                    playerNextAvian = time + player.avianInterval;
                    const isMax = (AVIANS[player.avian] || AVIANS.none).isMaxHP !== false;
                    const sourceHP = isMax ? player.maxHP : player.hp;
                    const avianDmg = calcHPDamage(player, enemy, sourceHP, player.avianHPPercent, isMax, pvpFactor);
                    const avianResult = dealDamage(enemy, avianDmg);
                    player.totalDamageDealt += avianResult.total;
                    player.dmgAvian += avianResult.total;
                    player.avianCount++;
                    const sn = avianResult.shielded > 0 ? ` (${formatNumber(avianResult.shielded)} blocked)` : '';
                    log(`Player Avian (Bee): ${formatNumber(avianResult.total)}${sn} [${player.avianHPPercent}% ${isMax ? 'Max' : 'Cur'} HP]`, 'damage');
                }
                if (enemyAvianType === 'timed' && enemy.avianHPPercent > 0 && time >= enemyNextAvian) {
                    enemyNextAvian = time + enemy.avianInterval;
                    const isMax = (AVIANS[enemy.avian] || AVIANS.none).isMaxHP !== false;
                    const sourceHP = isMax ? enemy.maxHP : enemy.hp;
                    const avianDmg = calcHPDamage(enemy, player, sourceHP, enemy.avianHPPercent, isMax, pvpFactor);
                    const avianResult = dealDamage(player, avianDmg, true);
                    enemy.totalDamageDealt += avianResult.total;
                    enemy.dmgAvian += avianResult.total;
                    enemy.avianCount++;
                    const sn = avianResult.shielded > 0 ? ` (${formatNumber(avianResult.shielded)} blocked)` : '';
                    log(`Enemy Avian (Bee): ${formatNumber(avianResult.total)}${sn} [${enemy.avianHPPercent}% ${isMax ? 'Max' : 'Cur'} HP]`, 'damage');
                }

                // Deity (healcount): fires every 16 heals (fixed threshold)
                if (playerAvianType === 'healcount' && player.avianHPPercent > 0 && player.healCount >= 16) {
                    player.healCount -= 16;
                    const avianDmg = calcHPDamage(player, enemy, player.hp, player.avianHPPercent, false, pvpFactor);
                    const avianResult = dealDamage(enemy, avianDmg);
                    player.totalDamageDealt += avianResult.total;
                    player.dmgAvian += avianResult.total;
                    player.avianCount++;
                    const sn = avianResult.shielded > 0 ? ` (${formatNumber(avianResult.shielded)} blocked)` : '';
                    log(`Player Avian (Deity): ${formatNumber(avianResult.total)}${sn} [${player.avianHPPercent}% Cur HP]`, 'damage');
                }
                if (enemyAvianType === 'healcount' && enemy.avianHPPercent > 0 && enemy.healCount >= 16) {
                    enemy.healCount -= 16;
                    const avianDmg = calcHPDamage(enemy, player, enemy.hp, enemy.avianHPPercent, false, pvpFactor);
                    const avianResult = dealDamage(player, avianDmg, true);
                    enemy.totalDamageDealt += avianResult.total;
                    enemy.dmgAvian += avianResult.total;
                    enemy.avianCount++;
                    const sn = avianResult.shielded > 0 ? ` (${formatNumber(avianResult.shielded)} blocked)` : '';
                    log(`Enemy Avian (Deity): ${formatNumber(avianResult.total)}${sn} [${enemy.avianHPPercent}% Cur HP]`, 'damage');
                }

                // === RAGE SLASH: +ATK% per second when >50% HP, max 30 stacks ===
                if (player.affixRageSlash && time >= playerNextRageSlash) {
                    playerNextRageSlash = time + 1;
                    if (player.hp > player.maxHP * 0.5 && player.rageSlashStacks < 30) {
                        player.rageSlashStacks++;
                        player.atk = player.baseATK * (1 + player.rageSlashStacks * player.affixRageSlashATK / 100);
                    }
                }
                if (enemy.affixRageSlash && time >= enemyNextRageSlash) {
                    enemyNextRageSlash = time + 1;
                    if (enemy.hp > enemy.maxHP * 0.5 && enemy.rageSlashStacks < 30) {
                        enemy.rageSlashStacks++;
                        enemy.atk = enemy.baseATK * (1 + enemy.rageSlashStacks * enemy.affixRageSlashATK / 100);
                    }
                }

                // General regen (ticks every 1s, affected by PvP healing reduction)
                if (player.regen > 0 && time >= playerNextGeneralRegen) {
                    playerNextGeneralRegen = time + 1;
                    const healed = heal(player, player.maxHP * (player.regen / 100));
                    if (healed > 0) log(`[Heal] Player Regen: ${formatNumber(healed)} (${player.regen}%)`, 'heal');
                }
                if (enemy.regen > 0 && time >= enemyNextGeneralRegen) {
                    enemyNextGeneralRegen = time + 1;
                    const healed = heal(enemy, enemy.maxHP * (enemy.regen / 100));
                    if (healed > 0) log(`[Heal] Enemy Regen: ${formatNumber(healed)} (${enemy.regen}%)`, 'heal');
                }

                sampleHP();
                time += TIME_STEP;
            }

            // Final sample
            hpHistory.times.push(time.toFixed(1));
            hpHistory.playerHP.push((player.hp / player.maxHP * 100).toFixed(1));
            hpHistory.enemyHP.push((enemy.hp / enemy.maxHP * 100).toFixed(1));

            if (player.hp <= 0 && enemy.hp <= 0) winner = 'Draw';
            else if (player.hp <= 0) winner = 'Enemy';
            else if (enemy.hp <= 0) winner = 'Player';
            else {
                const playerPct = player.hp / player.maxHP;
                const enemyPct = enemy.hp / enemy.maxHP;
                winner = playerPct > enemyPct ? 'Player (HP%)' : enemyPct > playerPct ? 'Enemy (HP%)' : 'Draw';
            }

            displayResults(player, enemy, time, winner, battleLog, hpHistory, skillEvents);
        }

        // Store full log globally for toggle
        let lastFullBattleLog = [];

        function displayResults(player, enemy, duration, winner, battleLog, hpHistory, skillEvents) {
            document.getElementById('results-section').classList.remove('hidden');
            lastFullBattleLog = battleLog;

            const playerHPPercent = Math.max(0, (player.hp / player.maxHP) * 100);
            const enemyHPPercent = Math.max(0, (enemy.hp / enemy.maxHP) * 100);

            document.getElementById('playerHPBar').style.width = playerHPPercent + '%';
            document.getElementById('playerHPBar').textContent = playerHPPercent.toFixed(1) + '%';
            document.getElementById('playerHPText').textContent = `HP: ${formatNumber(player.hp)} / ${formatNumber(player.maxHP)}`;

            document.getElementById('enemyHPBar').style.width = enemyHPPercent + '%';
            document.getElementById('enemyHPBar').textContent = enemyHPPercent.toFixed(1) + '%';
            document.getElementById('enemyHPText').textContent = `HP: ${formatNumber(enemy.hp)} / ${formatNumber(enemy.maxHP)}`;

            document.getElementById('resultWinner').textContent = winner;
            document.getElementById('resultWinner').style.color = winner.includes('Player') ? '#51cf66' : winner.includes('Enemy') ? '#ff6b6b' : '#ffd43b';
            document.getElementById('resultDuration').textContent = duration.toFixed(2) + 's';
            document.getElementById('resultPlayerDMG').textContent = formatNumber(player.totalDamageDealt);
            document.getElementById('resultEnemyDMG').textContent = formatNumber(enemy.totalDamageDealt);
            document.getElementById('resultPlayerDPS').textContent = formatNumber(player.totalDamageDealt / duration) + '/s';
            document.getElementById('resultEnemyDPS').textContent = formatNumber(enemy.totalDamageDealt / duration) + '/s';
            document.getElementById('resultPlayerHeals').textContent = player.healProcs;
            document.getElementById('resultEnemyHeals').textContent = enemy.healProcs;

            // Per-source damage breakdown
            function buildBreakdown(who, stats) {
                const classSkillName = stats.class === 'hunter' ? 'Piercing Boneforge' : 'Blades Reunion';
                const sources = [
                    ['Basic ATK', stats.dmgBasicATK],
                    ['Combo', stats.dmgCombo],
                    ['Counter', stats.dmgCounter],
                    [stats.class === 'sage' ? 'Sage Class Skill HP' : 'Hunter HP (1% Cur)', stats.dmgSageClassSkillHP],
                    ['Punch Counter', stats.dmgPunchCounter],
                    [`Class Skill (${classSkillName})`, stats.dmgClassSkill],
                    ['Active Skills', stats.dmgActiveSkills],
                    ['Skill DoTs', stats.dmgDot],
                    ['HP% DoTs', stats.dmgHpDot],
                    ['Clone', stats.dmgClone],
                    ['Wind Tear', stats.dmgWindTear],
                    ['Avian', stats.dmgAvian]
                ].filter(s => s[1] > 0);

                const counts = [
                    ['Counters', stats.counterCount],
                    ['Combos', stats.comboCount],
                    ['Evades', stats.evadeCount],
                    ['Class Skills', stats.classSkillCount],
                    ['Active Skills', stats.activeSkillCount],
                    ['Avian Procs', stats.avianCount],
                    ['Punch Counters', stats.punchCounterCount],
                    ['Wind Tears', stats.windTearCount],
                    ['Terminal Strikes', stats.terminalStrikeCount]
                ].filter(c => c[1] > 0);

                let html = `<div style="background:#1a1a2e;border-radius:8px;padding:15px;">`;
                html += `<h4 style="color:${who === 'Player' ? '#51cf66' : '#ff6b6b'};margin-bottom:10px;">${who}</h4>`;
                html += `<table style="width:100%;color:#ccc;font-size:0.85em;">`;
                html += `<tr style="border-bottom:1px solid #333;"><th style="text-align:left;padding:4px;">Source</th><th style="text-align:right;padding:4px;">Damage</th></tr>`;
                sources.forEach(([name, val]) => {
                    html += `<tr><td style="padding:3px 4px;">${name}</td><td style="text-align:right;padding:3px 4px;">${formatNumber(val)}</td></tr>`;
                });
                html += `<tr style="border-top:1px solid #555;font-weight:bold;"><td style="padding:3px 4px;">Total</td><td style="text-align:right;padding:3px 4px;">${formatNumber(stats.totalDamageDealt)}</td></tr>`;
                html += `</table>`;

                if (counts.length > 0) {
                    html += `<table style="width:100%;color:#aaa;font-size:0.8em;margin-top:10px;border-top:1px solid #333;">`;
                    for (let i = 0; i < counts.length; i += 2) {
                        html += `<tr>`;
                        html += `<td style="padding:2px 4px;">${counts[i][0]}</td><td style="text-align:right;padding:2px 4px;">${counts[i][1]}</td>`;
                        if (i + 1 < counts.length) {
                            html += `<td style="padding:2px 4px 2px 12px;">${counts[i+1][0]}</td><td style="text-align:right;padding:2px 4px;">${counts[i+1][1]}</td>`;
                        } else {
                            html += `<td></td><td></td>`;
                        }
                        html += `</tr>`;
                    }
                    html += `</table>`;
                }
                html += `</div>`;
                return html;
            }

            document.getElementById('damageBreakdown').innerHTML =
                buildBreakdown('Player', player) + buildBreakdown('Enemy', enemy);

            // Battle log
            document.getElementById('showFullLog').checked = false;
            renderBattleLog(false);

            // Store data globally for toggle updates
            lastHPHistory = hpHistory;
            lastSkillEvents = skillEvents;
            lastPlayerClass = player.class;
            lastEnemyClass = enemy.class;
            lastPlayerSkills = player.activeSkills.map(sk => sk.name);
            lastEnemySkills = enemy.activeSkills.map(sk => sk.name);

            // Build skill toggle checkboxes
            buildSkillToggles(player, enemy, skillEvents);
            renderHPChart();
        }

        function toggleFullLog() {
            renderBattleLog(document.getElementById('showFullLog').checked);
        }

        function renderBattleLog(showFull) {
            const logEl = document.getElementById('battleLog');
            const entries = showFull ? lastFullBattleLog : lastFullBattleLog.slice(-200);
            logEl.innerHTML = entries.map(entry =>
                `<span class="time">[${entry.time}s]</span> <span class="${entry.type}">${entry.msg}</span>`
            ).join('<br>');
            logEl.scrollTop = showFull ? 0 : logEl.scrollHeight;
        }

        // Global chart state for toggle updates
        let lastHPHistory = null;
        let lastSkillEvents = null;
        let lastPlayerClass = 'sage';
        let lastEnemyClass = 'sage';
        let lastPlayerSkills = [];
        let lastEnemySkills = [];

        const SKILL_COLORS_P = ['#51cf66','#74c0fc','#ffd43b','#cc5de8','#ff922b','#20c997'];
        const SKILL_COLORS_E = ['#ff6b6b','#ffa8a8','#f08c00','#e599f7','#fd7e14','#fa5252'];

        function buildSkillToggles(player, enemy, skillEvents) {
            // Build unique skill names from events
            const pNames = new Set();
            const eName = new Set();
            skillEvents.player.forEach(e => pNames.add(e.name));
            skillEvents.enemy.forEach(e => eName.add(e.name));

            let pHtml = '';
            let idx = 0;
            pNames.forEach(name => {
                const color = SKILL_COLORS_P[idx % SKILL_COLORS_P.length];
                pHtml += `<label style="color:${color};cursor:pointer;"><input type="checkbox" data-skill-toggle="p_${name}" onchange="renderHPChart()"> P: ${name}</label>`;
                idx++;
            });
            document.getElementById('skillTogglesPlayer').innerHTML = pHtml;

            let eHtml = '';
            idx = 0;
            eName.forEach(name => {
                const color = SKILL_COLORS_E[idx % SKILL_COLORS_E.length];
                eHtml += `<label style="color:${color};cursor:pointer;"><input type="checkbox" data-skill-toggle="e_${name}" onchange="renderHPChart()"> E: ${name}</label>`;
                idx++;
            });
            document.getElementById('skillTogglesEnemy').innerHTML = eHtml;
        }

        function renderHPChart() {
            if (!lastHPHistory) return;
            const hpHistory = lastHPHistory;
            const ctx = document.getElementById('hpChart').getContext('2d');

            if (hpChart) hpChart.destroy();

            const datasets = [
                {
                    label: 'Player HP %',
                    data: hpHistory.playerHP,
                    borderColor: '#51cf66',
                    backgroundColor: 'rgba(81, 207, 102, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'y'
                },
                {
                    label: 'Enemy HP %',
                    data: hpHistory.enemyHP,
                    borderColor: '#ff6b6b',
                    backgroundColor: 'rgba(255, 107, 107, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'y'
                }
            ];

            // CDR/ATK overlay lines
            if (document.getElementById('togglePlayerCDR').checked) {
                datasets.push({
                    label: 'Player CDR %',
                    data: hpHistory.playerCDR,
                    borderColor: '#51cf66',
                    borderWidth: 1.5,
                    borderDash: [6, 3],
                    fill: false,
                    tension: 0,
                    pointRadius: 0,
                    yAxisID: 'y'
                });
            }
            if (document.getElementById('toggleEnemyCDR').checked) {
                datasets.push({
                    label: 'Enemy CDR %',
                    data: hpHistory.enemyCDR,
                    borderColor: '#ff6b6b',
                    borderWidth: 1.5,
                    borderDash: [6, 3],
                    fill: false,
                    tension: 0,
                    pointRadius: 0,
                    yAxisID: 'y'
                });
            }
            if (document.getElementById('togglePlayerATK').checked) {
                datasets.push({
                    label: 'Player ATK %',
                    data: hpHistory.playerATK,
                    borderColor: '#74c0fc',
                    borderWidth: 1.5,
                    borderDash: [2, 2],
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'yATK'
                });
            }
            if (document.getElementById('toggleEnemyATK').checked) {
                datasets.push({
                    label: 'Enemy ATK %',
                    data: hpHistory.enemyATK,
                    borderColor: '#ffa8a8',
                    borderWidth: 1.5,
                    borderDash: [2, 2],
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    yAxisID: 'yATK'
                });
            }

            // Skill uptime bars - check which toggles are active
            let skillYLevel = -3;
            const hasAnySkillToggle = document.querySelectorAll('[data-skill-toggle]:checked').length > 0;

            // Player skill uptimes
            const pToggles = document.querySelectorAll('[data-skill-toggle^="p_"]:checked');
            let pIdx = 0;
            pToggles.forEach(toggle => {
                const skillName = toggle.dataset.skillToggle.slice(2);
                const color = SKILL_COLORS_P[pIdx % SKILL_COLORS_P.length];
                // Match color index to the skill's position in the toggle list
                const allP = document.querySelectorAll('[data-skill-toggle^="p_"]');
                let colorIdx = 0;
                allP.forEach((t, i) => { if (t.dataset.skillToggle.slice(2) === skillName) colorIdx = i; });
                const c = SKILL_COLORS_P[colorIdx % SKILL_COLORS_P.length];

                const events = lastSkillEvents.player.filter(e => e.name === skillName);
                const uptimeData = hpHistory.times.map(t => {
                    const tNum = parseFloat(t);
                    for (const ev of events) {
                        if (tNum >= ev.start && tNum < ev.end) return skillYLevel;
                    }
                    return null;
                });
                datasets.push({
                    label: `P: ${skillName}`,
                    data: uptimeData,
                    borderColor: c,
                    backgroundColor: c + '60',
                    borderWidth: 8,
                    fill: false,
                    stepped: 'before',
                    pointRadius: 0,
                    yAxisID: 'y'
                });
                skillYLevel -= 3;
                pIdx++;
            });

            // Enemy skill uptimes
            const eToggles = document.querySelectorAll('[data-skill-toggle^="e_"]:checked');
            let eIdx = 0;
            eToggles.forEach(toggle => {
                const skillName = toggle.dataset.skillToggle.slice(2);
                const allE = document.querySelectorAll('[data-skill-toggle^="e_"]');
                let colorIdx = 0;
                allE.forEach((t, i) => { if (t.dataset.skillToggle.slice(2) === skillName) colorIdx = i; });
                const c = SKILL_COLORS_E[colorIdx % SKILL_COLORS_E.length];

                const events = lastSkillEvents.enemy.filter(e => e.name === skillName);
                const uptimeData = hpHistory.times.map(t => {
                    const tNum = parseFloat(t);
                    for (const ev of events) {
                        if (tNum >= ev.start && tNum < ev.end) return skillYLevel;
                    }
                    return null;
                });
                datasets.push({
                    label: `E: ${skillName}`,
                    data: uptimeData,
                    borderColor: c,
                    backgroundColor: c + '60',
                    borderWidth: 8,
                    fill: false,
                    stepped: 'before',
                    pointRadius: 0,
                    yAxisID: 'y'
                });
                skillYLevel -= 3;
                eIdx++;
            });

            const showATK = document.getElementById('togglePlayerATK').checked || document.getElementById('toggleEnemyATK').checked;
            const yMin = hasAnySkillToggle ? skillYLevel - 2 : 0;

            hpChart = new Chart(ctx, {
                type: 'line',
                data: { labels: hpHistory.times, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        legend: { labels: { color: '#fff', font: { size: 10 } } },
                        tooltip: {
                            filter: item => item.parsed.y !== null,
                            callbacks: {
                                label: ctx => {
                                    if (ctx.dataset.label.includes('HP')) return ctx.dataset.label + ': ' + ctx.parsed.y + '%';
                                    if (ctx.dataset.label.includes('CDR')) return ctx.dataset.label + ': ' + ctx.parsed.y + '%';
                                    if (ctx.dataset.label.includes('ATK')) return ctx.dataset.label + ': ' + ctx.parsed.y + '%';
                                    return ctx.dataset.label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Time (seconds)', color: '#aaa' },
                            ticks: { color: '#aaa', maxTicksLimit: 12 },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            min: yMin, max: 100,
                            title: { display: true, text: 'HP %', color: '#aaa' },
                            ticks: {
                                color: '#aaa',
                                callback: v => v >= 0 ? v : ''
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        ...(showATK ? {
                            yATK: {
                                position: 'right',
                                title: { display: true, text: 'ATK % of Base', color: '#74c0fc' },
                                ticks: { color: '#74c0fc' },
                                grid: { drawOnChartArea: false }
                            }
                        } : {})
                    }
                }
            });
        }

        // ============================================
        // IMPORT/EXPORT (Per Player)
        // ============================================

        function exportConfig(who) {
            const config = {
                version: 'alpha-2.0',
                type: who,
                timestamp: new Date().toISOString(),
                data: gatherConfigForExport(who)
            };

            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lom_${who}_config_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function gatherConfigForExport(prefix) {
            const fields = [
                'Class', 'Level', 'ATK', 'HP', 'DEF', 'ATKSPD',
                'BasicATKMult', 'ComboMult', 'CounterMult', 'CritDMG', 'SkillDMG', 'SkillCritDMG', 'PalDMG', 'BossDMG',
                'Combo', 'Counter', 'CritRate', 'SkillCrit', 'Stun', 'Launch', 'Evasion', 'HealingRate', 'HealingAmount',
                'DMGRES', 'BasicATKRES', 'ComboRES', 'CounterRES', 'SkillRES', 'PalRES', 'BossRES', 'CritRES',
                'IgnoreEvasion', 'IgnoreCombo', 'IgnoreCounter', 'IgnoreCrit', 'IgnoreStun', 'IgnoreLaunch', 'IgnoreRegen',
                'Regen'
            ];

            const config = {};
            fields.forEach(field => {
                const el = document.getElementById(prefix + field);
                if (el) config[field] = el.value;
            });

            // Talents - checkboxes
            config.TalentAscension = document.getElementById(prefix + 'TalentAscension').checked;
            config.TalentRampage = document.getElementById(prefix + 'TalentRampage').checked;
            config.TalentEagerMomentum = document.getElementById(prefix + 'TalentEagerMomentum').checked;
            config.TalentGaleBarrage = document.getElementById(prefix + 'TalentGaleBarrage').checked;
            config.TalentTemporalCompression = document.getElementById(prefix + 'TalentTemporalCompression').checked;
            config.TalentEndlessOutburst = document.getElementById(prefix + 'TalentEndlessOutburst').checked;
            // Talents - numeric
            config.TalentWound = document.getElementById(prefix + 'TalentWound').value;
            config.TalentEnergyRegen = document.getElementById(prefix + 'TalentEnergyRegen').value;
            config.TalentCounterRejuv = document.getElementById(prefix + 'TalentCounterRejuv').value;
            config.TalentComboHealing = document.getElementById(prefix + 'TalentComboHealing').value;
            config.TalentSkillRegen = document.getElementById(prefix + 'TalentSkillRegen').value;

            config.PalWolf = document.getElementById(prefix + 'PalWolf').checked;
            config.PalPup = document.getElementById(prefix + 'PalPup').checked;
            config.PalHydro = document.getElementById(prefix + 'PalHydro').checked;
            config.PalBDuck = document.getElementById(prefix + 'PalBDuck').checked;
            config.PalPuppyFervor = document.getElementById(prefix + 'PalPuppyFervor').checked;
            config.PalFloralPanda = document.getElementById(prefix + 'PalFloralPanda').checked;
            config.PalAlpacaBell = document.getElementById(prefix + 'PalAlpacaBell').checked;
            config.PalMellowCloud = document.getElementById(prefix + 'PalMellowCloud').checked;
            config.PalTreasureDragon = document.getElementById(prefix + 'PalTreasureDragon').checked;
            config.Avian = document.getElementById(prefix + 'Avian').value;
            config.AvianHPPercent = document.getElementById(prefix + 'AvianHPPercent').value;
            config.AvianInterval = document.getElementById(prefix + 'AvianInterval').value;

            // Relics
            config.RelicKite = document.getElementById(prefix + 'RelicKite').checked;
            config.RelicFlameBook = document.getElementById(prefix + 'RelicFlameBook').checked;
            config.RelicNecklace = document.getElementById(prefix + 'RelicNecklace').value;
            config.RelicStatue = document.getElementById(prefix + 'RelicStatue').value;
            config.RelicSpore = document.getElementById(prefix + 'RelicSpore').value;

            // Avian affixes
            config.AffixPunchCounter = document.getElementById(prefix + 'AffixPunchCounter').checked;
            config.AffixPunchCounterHP = document.getElementById(prefix + 'AffixPunchCounterHP').value;
            config.AffixWindTear = document.getElementById(prefix + 'AffixWindTear').checked;
            config.AffixWindTearHP = document.getElementById(prefix + 'AffixWindTearHP').value;
            config.AffixRageSlash = document.getElementById(prefix + 'AffixRageSlash').checked;
            config.AffixRageSlashATK = document.getElementById(prefix + 'AffixRageSlashATK').value;
            config.AffixTerminalStrike = document.getElementById(prefix + 'AffixTerminalStrike').checked;
            config.AffixTerminalStrikeChance = document.getElementById(prefix + 'AffixTerminalStrikeChance').value;
            config.AffixNoSpeeding = document.getElementById(prefix + 'AffixNoSpeeding').checked;
            config.AffixNoSpeedingReduce = document.getElementById(prefix + 'AffixNoSpeedingReduce').value;

            // Active skills (5 slots)
            config.Skills = [];
            for (let i = 0; i < 5; i++) {
                const sel = document.getElementById(prefix + 'Skill' + i);
                const isCustom = document.getElementById(prefix + 'Skill' + i + 'Custom').checked;
                const customDmg = document.getElementById(prefix + 'Skill' + i + 'Dmg').value;
                config.Skills.push({ id: sel.value, custom: isCustom, dmg: customDmg });
            }

            return config;
        }

        function importConfig(who) {
            const fileInput = document.getElementById('import' + who.charAt(0).toUpperCase() + who.slice(1) + 'File');
            if (!fileInput.files.length) return;

            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const config = JSON.parse(e.target.result);
                    applyConfig(who, config.data);
                    alert(`${who.charAt(0).toUpperCase() + who.slice(1)} configuration loaded!`);
                } catch (err) {
                    alert('Error loading configuration: ' + err.message);
                }
            };
            reader.readAsText(file);
            fileInput.value = '';
        }

        function applyConfig(prefix, config) {
            Object.keys(config).forEach(key => {
                if (key === 'Skills') return; // handle separately
                const el = document.getElementById(prefix + key);
                if (el) {
                    if (el.type === 'checkbox') el.checked = config[key];
                    else el.value = config[key];
                }
            });
            // Apply skill slots
            if (config.Skills && Array.isArray(config.Skills)) {
                config.Skills.forEach((sk, i) => {
                    const sel = document.getElementById(prefix + 'Skill' + i);
                    const customCb = document.getElementById(prefix + 'Skill' + i + 'Custom');
                    const dmgInput = document.getElementById(prefix + 'Skill' + i + 'Dmg');
                    if (sel) sel.value = sk.id || '';
                    if (customCb) customCb.checked = sk.custom || false;
                    if (dmgInput) dmgInput.value = sk.dmg || '';
                    onSkillSlotChange(prefix, i);
                });
            }
        }

        function resetFields(who) {
            if (!confirm(`Reset all ${who} fields to defaults?`)) return;

            const selectedClass = document.getElementById(who + 'Class').value;
            const isHunter = selectedClass === 'hunter';

            const defaults = isHunter ? {
                Class: 'hunter', Level: '200', ATK: '12000', HP: '4000', DEF: '5500', ATKSPD: '3.7',
                BasicATKMult: '7500', ComboMult: '3500', CounterMult: '5500', CritDMG: '1000',
                SkillDMG: '1450', SkillCritDMG: '160', PalDMG: '1377', BossDMG: '30',
                Combo: '30', Counter: '0', CritRate: '35', SkillCrit: '0',
                Stun: '0', Launch: '0', Evasion: '200', HealingRate: '50', HealingAmount: '0.35',
                DMGRES: '30', BasicATKRES: '15', ComboRES: '35', CounterRES: '35',
                SkillRES: '55', PalRES: '35', BossRES: '20', CritRES: '3000',
                IgnoreEvasion: '135', IgnoreCombo: '60', IgnoreCounter: '60', IgnoreCrit: '5',
                IgnoreStun: '0', IgnoreLaunch: '0', IgnoreRegen: '0',
                Regen: '9.5'
            } : {
                Class: 'sage', Level: '200', ATK: '12000', HP: '4000', DEF: '5500', ATKSPD: '3.21',
                BasicATKMult: '7500', ComboMult: '3500', CounterMult: '5500', CritDMG: '1000',
                SkillDMG: '1450', SkillCritDMG: '160', PalDMG: '1377', BossDMG: '30',
                Combo: '0', Counter: '135', CritRate: '0', SkillCrit: '0',
                Stun: '0', Launch: '0', Evasion: '95', HealingRate: '50', HealingAmount: '0.35',
                DMGRES: '45', BasicATKRES: '15', ComboRES: '35', CounterRES: '35',
                SkillRES: '55', PalRES: '35', BossRES: '20', CritRES: '3000',
                IgnoreEvasion: '135', IgnoreCombo: '60', IgnoreCounter: '60', IgnoreCrit: '5',
                IgnoreStun: '0', IgnoreLaunch: '0', IgnoreRegen: '0',
                Regen: '9.5'
            };

            Object.keys(defaults).forEach(key => {
                const el = document.getElementById(who + key);
                if (el) el.value = defaults[key];
            });

            // Reset talents
            document.getElementById(who + 'TalentAscension').checked = true;
            document.getElementById(who + 'TalentRampage').checked = false;
            document.getElementById(who + 'TalentEagerMomentum').checked = false;
            document.getElementById(who + 'TalentGaleBarrage').checked = false;
            document.getElementById(who + 'TalentTemporalCompression').checked = true;
            document.getElementById(who + 'TalentEndlessOutburst').checked = false;
            document.getElementById(who + 'TalentWound').value = '20';
            document.getElementById(who + 'TalentEnergyRegen').value = '20';
            document.getElementById(who + 'TalentCounterRejuv').value = '1';
            document.getElementById(who + 'TalentComboHealing').value = '0';
            document.getElementById(who + 'TalentSkillRegen').value = '0.88';

            document.getElementById(who + 'PalWolf').checked = true;
            document.getElementById(who + 'PalPup').checked = true;
            document.getElementById(who + 'PalHydro').checked = true;
            document.getElementById(who + 'PalBDuck').checked = false;
            document.getElementById(who + 'PalPuppyFervor').checked = false;
            document.getElementById(who + 'PalFloralPanda').checked = false;
            document.getElementById(who + 'PalAlpacaBell').checked = false;
            document.getElementById(who + 'PalMellowCloud').checked = false;
            document.getElementById(who + 'PalTreasureDragon').checked = false;

            // Avian defaults (Bee for Hunter, Deity for Sage)
            if (isHunter) {
                document.getElementById(who + 'Avian').value = 'bee';
                document.getElementById(who + 'AvianHPPercent').value = '3.58';
                document.getElementById(who + 'AvianInterval').value = '5';
            } else {
                document.getElementById(who + 'Avian').value = 'deity';
                document.getElementById(who + 'AvianHPPercent').value = '5.87';
                document.getElementById(who + 'AvianInterval').value = '16';
            }

            // Reset affixes
            document.getElementById(who + 'AffixPunchCounter').checked = true;
            document.getElementById(who + 'AffixPunchCounterHP').value = '1.2';
            document.getElementById(who + 'AffixWindTear').checked = true;
            document.getElementById(who + 'AffixWindTearHP').value = '2.4';
            document.getElementById(who + 'AffixRageSlash').checked = false;
            document.getElementById(who + 'AffixRageSlashATK').value = '0.4';
            document.getElementById(who + 'AffixTerminalStrike').checked = false;
            document.getElementById(who + 'AffixTerminalStrikeChance').value = '8';
            document.getElementById(who + 'AffixNoSpeeding').checked = true;
            document.getElementById(who + 'AffixNoSpeedingReduce').value = '19.2';

            // Reset relics
            document.getElementById(who + 'RelicKite').checked = true;
            document.getElementById(who + 'RelicFlameBook').checked = true;
            document.getElementById(who + 'RelicNecklace').value = 'abyss';
            document.getElementById(who + 'RelicStatue').value = 'energy';
            document.getElementById(who + 'RelicSpore').value = 'potent';

            // Reset active skill slots to default loadout
            const defaultSkills = [
                { id: '27', custom: true, dmg: '8172' },
                { id: '28', custom: true, dmg: '6538' },
                { id: '13', custom: true, dmg: '15097' },
                { id: '33', custom: true, dmg: '4105' },
                { id: '32', custom: true, dmg: '2257' }
            ];
            for (let i = 0; i < 5; i++) {
                const sk = defaultSkills[i];
                document.getElementById(who + 'Skill' + i).value = sk.id;
                document.getElementById(who + 'Skill' + i + 'Custom').checked = sk.custom;
                document.getElementById(who + 'Skill' + i + 'Dmg').value = sk.dmg;
                onSkillSlotChange(who, i);
            }
        }

        // =====================================
        // OCR Screenshot Import Functions (Improved)
        // =====================================
        
        // File storage
        const ocrFiles = new Array(6).fill(null);
        
        // Extracted stats with confidence
        let extractedStats = { player: {}, enemy: {} };

        // Stat label to form field mapping with validation ranges
        // IMPORTANT: Ordered by specificity - longest/most specific labels FIRST
        const statMappings = [
            // Most specific first (contains other label names)
            { label: 'Ignore Evasion', field: 'IgnoreEvasion', convert: 'percent', min: 0, max: 500 },
            { label: 'Ignore Combo', field: 'IgnoreCombo', convert: 'percent', min: 0, max: 200 },
            { label: 'Ignore Counter', field: 'IgnoreCounter', convert: 'percent', min: 0, max: 200 },
            { label: 'Ignore Crit', field: 'IgnoreCrit', convert: 'percent', min: 0, max: 100 },
            { label: 'Ignore Stun', field: 'IgnoreStun', convert: 'percent', min: 0, max: 100 },
            { label: 'Ignore Launch', field: 'IgnoreLaunch', convert: 'percent', min: 0, max: 100 },
            { label: 'Ignore Regen', field: 'IgnoreRegen', convert: 'percent', min: 0, max: 100 },
            
            // Resistances (before simpler versions)
            { label: 'Basic ATK DMG RES', field: 'BasicATKRES', convert: 'percent', min: 0, max: 80 },
            { label: 'Combo DMG RES', field: 'ComboRES', convert: 'percent', min: 0, max: 80 },
            { label: 'Counter DMG RES', field: 'CounterRES', convert: 'percent', min: 0, max: 80 },
            { label: 'Skill DMG RES', field: 'SkillRES', convert: 'percent', min: 0, max: 80 },
            { label: 'Pal DMG RES', field: 'PalRES', convert: 'percent', min: 0, max: 120 },
            { label: 'Boss DMG RES', field: 'BossRES', convert: 'percent', min: 0, max: 80 },
            
            // Multipliers (before simpler versions)
            { label: 'Basic ATK Multiplier', field: 'BasicATKMult', convert: 'percent', min: 100, max: 50000 },
            { label: 'Combo Multiplier', field: 'ComboMult', convert: 'percent', min: 100, max: 50000 },
            { label: 'Counter Multiplier', field: 'CounterMult', convert: 'percent', min: 100, max: 50000 },
            
            // Skill stats (before simpler Skill DMG)
            { label: 'Skill Crit DMG', field: 'SkillCritDMG', convert: 'percent', min: 0, max: 1000 },
            { label: 'Skill Crit', field: 'SkillCrit', convert: 'percent', min: 0, max: 100 },
            { label: 'Skill DMG', field: 'SkillDMG', convert: 'percent', min: 100, max: 10000 },
            
            // Crit stats (Crit DMG before Crit Rate since "Crit" is in both)
            { label: 'Crit DMG', field: 'CritDMG', convert: 'percent', min: 150, max: 5000 },
            { label: 'Crit RES', field: 'CritRES', convert: 'percent', min: 50, max: 10000 },
            { label: 'Crit Rate', field: 'CritRate', convert: 'percent', min: 0, max: 100 },
            
            // Core stats
            { label: 'Final HP', field: 'HP', convert: 'billions', min: 1, max: 100000 },
            { label: 'Final ATK', field: 'ATK', convert: 'millions', min: 100, max: 100000 },
            { label: 'Final DEF', field: 'DEF', convert: 'millions', min: 100, max: 100000 },
            { label: 'Final ATK SPD', field: 'ATKSPD', convert: 'number', min: 1, max: 10 },
            
            // Combat rates (simple names - matched AFTER more specific ones)
            { label: 'Counterstrike', field: 'Counter', convert: 'percent', min: 0, max: 200 },
            { label: 'Combo', field: 'Combo', convert: 'percent', min: 0, max: 100 },
            { label: 'Evasion', field: 'Evasion', convert: 'percent', min: 0, max: 200 },
            { label: 'Stun', field: 'Stun', convert: 'percent', min: 0, max: 100 },
            { label: 'Launch', field: 'Launch', convert: 'percent', min: 0, max: 100 },
            { label: 'Regeneration', field: 'Regen', convert: 'percent', min: 0, max: 50 },
            
            // Boss/Pal DMG
            { label: 'Boss DMG', field: 'BossDMG', convert: 'percent', min: 0, max: 500 },
            { label: 'Pal DMG', field: 'PalDMG', convert: 'percent', min: 100, max: 5000 },
            
            // DMG RES (generic - last)
            { label: 'DMG RES', field: 'DMGRES', convert: 'percent', min: 0, max: 80 },
            
            // Healing
            { label: 'Healing Rate', field: 'HealingRate', convert: 'percent', min: 0, max: 200 },
            { label: 'Healing Amount', field: 'HealingAmount', convert: 'percent', min: 0, max: 10 }
        ];

        // Labels to SKIP (these feed into other stats)
        const skipLabels = ['HP Bonus', 'ATK Bonus', 'DEF Bonus', 'ATK SPD Bonus', 'Final DMG Boost', 'Final DMG RES'];

        const classMapping = {
            'Martial Sage': 'sage',
            'Sacred Hunter': 'hunter',
            'Plume Monarch': 'archer',
            'Flame Wizard': 'mage',
            'Crystal Sage': 'crystal',
            'Shadow Assassin': 'assassin'
        };

        function handleOCRUpload(index, input) {
            if (input.files && input.files[0]) {
                ocrFiles[index] = input.files[0];
                const zone = input.parentElement;
                zone.classList.add('has-file');
                zone.querySelector('.status').textContent = '‚úì ' + input.files[0].name.substring(0, 12);
            }
        }

        function clearOCR() {
            ocrFiles.fill(null);
            extractedStats = { player: {}, enemy: {} };
            
            for (let i = 0; i <= 5; i++) {
                const input = document.getElementById('ocr' + i);
                if (input) {
                    const zone = input.parentElement;
                    input.value = '';
                    zone.classList.remove('has-file', 'processing');
                    zone.querySelector('.status').textContent = 'Click to upload';
                }
            }
            
            document.getElementById('ocrProgress').classList.remove('active');
            document.getElementById('ocrStatus').textContent = '';
            document.getElementById('ocrReviewPanel').style.display = 'none';
        }

        async function processOCR() {
            const uploadedCount = ocrFiles.filter(f => f !== null).length;
            
            if (uploadedCount === 0) {
                alert('Please upload at least one screenshot');
                return;
            }

            const progressBar = document.getElementById('ocrProgressBar');
            const progressContainer = document.getElementById('ocrProgress');
            const statusEl = document.getElementById('ocrStatus');

            progressContainer.classList.add('active');
            document.getElementById('ocrReviewPanel').style.display = 'none';
            
            extractedStats = { player: {}, enemy: {} };
            let processedCount = 0;

            try {
                statusEl.textContent = 'Initializing OCR engine...';
                const worker = await Tesseract.createWorker('eng');
                
                // Configure for better accuracy
                await worker.setParameters({
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,%+-:| ',
                });

                for (let i = 0; i < ocrFiles.length; i++) {
                    if (!ocrFiles[i]) continue;

                    const zone = document.getElementById('ocr' + i).parentElement;
                    zone.classList.add('processing');
                    
                    statusEl.textContent = `Processing screenshot ${i === 0 ? 'Profile' : 'Compare ' + i}...`;
                    
                    const { data } = await worker.recognize(ocrFiles[i]);
                    const text = data.text;
                    const confidence = data.confidence;

                    console.log(`Screenshot ${i} OCR (confidence: ${confidence}%):\n`, text);

                    if (i === 0) {
                        parseProfileCard(text);
                    } else {
                        parseCompareScreen(text);
                    }

                    zone.classList.remove('processing');
                    processedCount++;
                    const progress = Math.round((processedCount / uploadedCount) * 100);
                    progressBar.style.width = progress + '%';
                    progressBar.textContent = progress + '%';
                }

                await worker.terminate();

                statusEl.textContent = 'Processing complete! Review stats below.';
                showReviewPanel();

            } catch (error) {
                statusEl.textContent = 'Error: ' + error.message;
                console.error('OCR Error:', error);
            }
        }

        function parseProfileCard(text) {
            const lines = text.split('\n');
            
            for (const line of lines) {
                // Look for level
                const levelMatch = line.match(/Lv\.?\s*(\d+)/i);
                if (levelMatch) {
                    const level = parseInt(levelMatch[1]);
                    extractedStats.player.Level = { value: level, confidence: 90, inRange: level >= 1 && level <= 220 };
                    extractedStats.enemy.Level = { value: level, confidence: 90, inRange: level >= 1 && level <= 220 };
                }

                // Look for class
                for (const [className, classValue] of Object.entries(classMapping)) {
                    if (line.toLowerCase().includes(className.toLowerCase())) {
                        extractedStats.player.Class = { value: classValue, confidence: 95, inRange: true };
                        extractedStats.enemy.Class = { value: classValue, confidence: 95, inRange: true };
                        break;
                    }
                }
            }
        }

        function parseCompareScreen(text) {
            const lines = text.split('\n');
            
            // Track which fields we've already matched to avoid duplicates
            const matchedFields = new Set();
            
            for (const line of lines) {
                // Skip empty lines
                if (!line.trim()) continue;
                
                // Skip known irrelevant labels
                if (skipLabels.some(skip => line.includes(skip))) continue;

                // Try to match each stat mapping IN ORDER (most specific first)
                for (const mapping of statMappings) {
                    // Skip if already matched this field
                    if (matchedFields.has(mapping.field)) continue;
                    
                    // Check if line contains this exact label
                    const labelIndex = line.toLowerCase().indexOf(mapping.label.toLowerCase());
                    if (labelIndex === -1) continue;
                    
                    // Extract the part after the label
                    const afterLabel = line.substring(labelIndex + mapping.label.length);
                    
                    // Look for two numbers (player value, enemy value)
                    const numbers = afterLabel.match(/[\d,]+\.?\d*[BMK%]?/gi);
                    
                    if (numbers && numbers.length >= 1) {
                        // Parse player value (first number)
                        const playerVal = parseStatValue(numbers[0], mapping.convert);
                        if (playerVal !== null) {
                            const recovered = recoverDecimal(playerVal, mapping.min, mapping.max);
                            extractedStats.player[mapping.field] = {
                                value: recovered.value,
                                confidence: recovered.corrected ? 65 : (recovered.inRange ? 85 : 40),
                                inRange: recovered.inRange,
                                corrected: recovered.corrected,
                                label: mapping.label
                            };
                        }
                        
                        // Parse enemy value (second number if exists)
                        if (numbers.length >= 2) {
                            const enemyVal = parseStatValue(numbers[1], mapping.convert);
                            if (enemyVal !== null) {
                                const recovered = recoverDecimal(enemyVal, mapping.min, mapping.max);
                                extractedStats.enemy[mapping.field] = {
                                    value: recovered.value,
                                    confidence: recovered.corrected ? 65 : (recovered.inRange ? 85 : 40),
                                    inRange: recovered.inRange,
                                    corrected: recovered.corrected,
                                    label: mapping.label
                                };
                            }
                        }
                        
                        matchedFields.add(mapping.field);
                        break; // Move to next line after successful match
                    }
                }
            }
        }

        // Smart decimal recovery - fixes OCR dropping decimal points
        // e.g., "3768.52" read as "376852" -> try dividing to find valid value
        function recoverDecimal(value, min, max) {
            // First check if already in range
            if (value >= min && value <= max) {
                return { value: value, inRange: true, corrected: false };
            }
            
            // Value is out of range - try to recover by dividing
            // This handles cases where OCR missed decimal point
            const divisors = [10, 100, 1000, 10000];
            
            for (const divisor of divisors) {
                const corrected = value / divisor;
                if (corrected >= min && corrected <= max) {
                    console.log(`Decimal recovery: ${value} -> ${corrected} (√∑${divisor})`);
                    return { value: corrected, inRange: true, corrected: true };
                }
            }
            
            // Also try if value is too SMALL (rare, but possible if OCR added decimals)
            const multipliers = [10, 100];
            for (const mult of multipliers) {
                const corrected = value * mult;
                if (corrected >= min && corrected <= max && value < min) {
                    console.log(`Decimal recovery (multiply): ${value} -> ${corrected} (√ó${mult})`);
                    return { value: corrected, inRange: true, corrected: true };
                }
            }
            
            // Couldn't recover - return original with inRange: false
            return { value: value, inRange: false, corrected: false };
        }

        function parseStatValue(str, convertType) {
            if (!str) return null;
            
            // Clean the string
            str = str.trim().replace(/,/g, '').replace(/\s/g, '');
            
            // Extract number and suffix
            const match = str.match(/^([\d.]+)\s*([BMK%]?)$/i);
            if (!match) return null;

            let value = parseFloat(match[1]);
            const suffix = match[2].toUpperCase();

            if (isNaN(value)) return null;

            // Handle suffix conversions
            switch (convertType) {
                case 'billions':
                    if (suffix === 'B') return value;
                    if (suffix === 'M') return value / 1000;
                    if (suffix === 'K') return value / 1000000;
                    // If no suffix but large number, assume it's in billions
                    return value;
                    
                case 'millions':
                    if (suffix === 'B') return value * 1000;
                    if (suffix === 'M') return value;
                    if (suffix === 'K') return value / 1000;
                    return value;
                    
                case 'percent':
                    return value;
                    
                case 'number':
                default:
                    return value;
            }
        }

        function showReviewPanel() {
            const mode = document.querySelector('input[name="ocrImportMode"]:checked').value;
            const reviewPanel = document.getElementById('ocrReviewPanel');
            const playerReview = document.getElementById('ocrPlayerReview');
            const enemyReview = document.getElementById('ocrEnemyReview');
            const enemyColumn = document.getElementById('ocrEnemyColumn');

            // Generate player stats HTML
            playerReview.innerHTML = generateReviewHTML(extractedStats.player, 'player');
            
            // Show/hide enemy column based on mode
            if (mode === 'fullMatchup') {
                enemyColumn.style.display = 'block';
                enemyReview.innerHTML = generateReviewHTML(extractedStats.enemy, 'enemy');
            } else {
                enemyColumn.style.display = 'none';
            }

            reviewPanel.style.display = 'block';
        }

        function generateReviewHTML(stats, prefix) {
            if (Object.keys(stats).length === 0) {
                return '<div style="color: #888; text-align: center; padding: 20px;">No stats extracted. Try uploading clearer screenshots.</div>';
            }

            let html = '';
            for (const [field, data] of Object.entries(stats)) {
                let statusClass = 'confident';
                let statusIcon = '‚úÖ';
                
                if (!data.inRange) {
                    statusClass = 'error';
                    statusIcon = '‚ùå';
                } else if (data.corrected) {
                    statusClass = 'warning';
                    statusIcon = 'üîß'; // Auto-corrected decimal
                } else if (data.confidence < 70) {
                    statusClass = 'warning';
                    statusIcon = '‚ö†Ô∏è';
                }

                const displayValue = typeof data.value === 'number' ? 
                    (Number.isInteger(data.value) ? data.value : data.value.toFixed(2)) : 
                    data.value;

                const correctedNote = data.corrected ? ' <small style="color:#888">(auto-fixed)</small>' : '';

                html += `
                    <div class="ocr-stat-item ${statusClass}">
                        <span class="stat-name">${data.label || field}${correctedNote}</span>
                        <span class="stat-value">
                            <input type="text" id="ocr_${prefix}_${field}" value="${displayValue}">
                            ${statusIcon}
                        </span>
                    </div>
                `;
            }
            return html;
        }

        function applyOCRStats() {
            const mode = document.querySelector('input[name="ocrImportMode"]:checked').value;
            
            // Apply player stats
            for (const [field, data] of Object.entries(extractedStats.player)) {
                const reviewInput = document.getElementById('ocr_player_' + field);
                const formInput = document.getElementById('player' + field);
                
                if (reviewInput && formInput) {
                    formInput.value = reviewInput.value;
                }
            }
            
            // Apply enemy stats if full matchup
            if (mode === 'fullMatchup') {
                for (const [field, data] of Object.entries(extractedStats.enemy)) {
                    const reviewInput = document.getElementById('ocr_enemy_' + field);
                    const formInput = document.getElementById('enemy' + field);
                    
                    if (reviewInput && formInput) {
                        formInput.value = reviewInput.value;
                    }
                }
            }

            // Switch to player tab
            showTab('player');
            alert('Stats applied! Review the Player and Enemy tabs to verify.');
        }

        function cancelOCR() {
            document.getElementById('ocrReviewPanel').style.display = 'none';
            document.getElementById('ocrStatus').textContent = 'Import cancelled.';
        }

        function showOCRInstructions() {
            alert(`Import Screenshot Import Instructions:

1. PROFILE CARD (Screenshot 1):
   - Open opponent's profile
   - Screenshot the card showing Name, Class, Level

2. COMPARE SCREEN (Screenshots 2-6):
   - Tap "Compare" button on profile
   - Take 5 screenshots as you scroll down:
     ‚Ä¢ Screenshot 2: Top (HP, ATK, DEF, Crit stats)
     ‚Ä¢ Screenshot 3: Combo, Counter, Stun, Evasion
     ‚Ä¢ Screenshot 4: Multipliers and RES stats
     ‚Ä¢ Screenshot 5: Skill, Boss, Pal stats
     ‚Ä¢ Screenshot 6: Bottom (Healing, DMG RES)

3. REVIEW & APPLY:
   - Upload screenshots in order
   - Click "Process Screenshots"
   - Review flagged stats (‚ö†Ô∏è or ‚ùå)
   - Edit any incorrect values
   - Click "Apply Stats to Form"

TIPS:
‚Ä¢ High-quality screenshots work best
‚Ä¢ Avoid cropping too tight
‚Ä¢ Stats flagged ‚ùå are likely misread - verify manually`);
        }
        // Initialize skill slot UI
        buildSkillSlots();
    </script>
</body>
</html>
